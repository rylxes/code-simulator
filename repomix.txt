This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where comments have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.test.ts, *.sh, .idea, .github, .gitignore, repomix.*, **/*.md, dist, src/codesimulator/resources/code, src/codesimulator/back, build, tests
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  codesimulator/
    resources/
      applications.json
      config.json
      README
    __main__.py
    actions.py
    app_switcher.py
    app.py
    config.py
    key_handler.py
    language_formatter.py
    logging_config.py
    mouse.py
    path_utils.py
CHANGELOG
LICENSE
pyproject.toml
README.rst

================================================================
Files
================================================================

================
File: src/codesimulator/resources/applications.json
================
 1: {
 2:   "darwin": {
 3:     "applications": [
 4:       {
 5:         "name": "Google Chrome",
 6:         "process_name": "Google Chrome",
 7:         "bundle_id": "com.google.Chrome"
 8:       },
 9:       {
10:         "name": "IntelliJ IDEA",
11:         "process_name": "IntelliJ IDEA",
12:         "bundle_id": "com.jetbrains.intellij"
13:       },
14:       {
15:         "name": "Sublime Text",
16:         "process_name": "Sublime Text",
17:         "bundle_id": "com.sublimetext.4"
18:       }
19:     ]
20:   },
21:   "win32": {
22:     "applications": [
23:       {
24:         "name": "Google Chrome",
25:         "process_name": "chrome.exe",
26:         "window_class": "Chrome_WidgetWin_1"
27:       },
28:       {
29:         "name": "IntelliJ IDEA",
30:         "process_name": "idea64.exe",
31:         "window_class": "SunAwtFrame"
32:       },
33:       {
34:         "name": "Sublime Text",
35:         "process_name": "sublime_text.exe",
36:         "window_class": "PX_WINDOW_CLASS"
37:       }
38:     ]
39:   },
40:   "linux": {
41:     "applications": [
42:       {
43:         "name": "Google Chrome",
44:         "process_name": "chrome",
45:         "window_class": "Google-chrome"
46:       },
47:       {
48:         "name": "IntelliJ IDEA",
49:         "process_name": "idea.sh",
50:         "window_class": "jetbrains-idea"
51:       },
52:       {
53:         "name": "Sublime Text",
54:         "process_name": "sublime_text",
55:         "window_class": "sublime_text"
56:       }
57:     ]
58:   }
59: }

================
File: src/codesimulator/resources/config.json
================
 1: {
 2:     "code": {
 3:         "language": "php",
 4:         "indent_size": 2,
 5:         "max_line_length": 80
 6:     },
 7:     "typing_speed": {
 8:         "min": 0.15,
 9:         "max": 0.25,
10:         "line_break": [0.5, 1.0],
11:         "mistake_rate": 0.09
12:     }
13: }

================
File: src/codesimulator/resources/README
================
1: Put any application resources (e.g., icons and resources) here;
2: they can be referenced in code as "resources/filename".

================
File: src/codesimulator/__main__.py
================
1: from codesimulator.app import main
2: 
3: if __name__ == "__main__":
4:     main().main_loop()

================
File: src/codesimulator/actions.py
================
  1: import asyncio
  2: import os
  3: import random
  4: import time
  5: import sys
  6: import json
  7: from typing import Optional
  8: 
  9: import pyautogui
 10: 
 11: from .app_switcher import AppSwitcher
 12: from .config import AppConfig
 13: from .language_formatter import FormatterFactory
 14: from .logging_config import logger
 15: from .mouse import MouseController
 16: 
 17: 
 18: class ActionSimulator:
 19: 
 20: 
 21:     def __init__(self, text_box, app=None):
 22:         self.text_box = text_box
 23:         self.app = app
 24:         self.loop_flag = False
 25:         self._configure_pyautogui()
 26:         self.app_config = AppConfig(app)
 27:         self.app_switcher = AppSwitcher(self.app_config)
 28:         self.formatter_factory = FormatterFactory()
 29:         self.formatter = None
 30:         self.mouse_controller = MouseController()
 31:         self.simulation_mode = "Hybrid"
 32: 
 33:         self.config = self._load_config()
 34:         self._setup_from_config()
 35: 
 36: 
 37:         self.code_files = self._get_code_files()
 38:         self.current_code_index = 0
 39: 
 40:         self.original_indentations = {}
 41: 
 42:     def _setup_from_config(self):
 43:         try:
 44:             code_config = self.config.get('code', {})
 45:             self.language = code_config.get('language', 'python')
 46:             self.indent_size = code_config.get('indent_size', 4)
 47:             self.max_line_length = code_config.get('max_line_length', 80)
 48:             typing_config = self.config.get('typing_speed', {})
 49:             self.typing_speed = {
 50:                 'min': typing_config.get('min', 0.03),
 51:                 'max': typing_config.get('max', 0.07),
 52:                 'line_break': tuple(typing_config.get('line_break', [0.5, 1.0])),
 53:                 'mistake_rate': typing_config.get('mistake_rate', 0.07)
 54:             }
 55:             logger.info("Successfully configured simulation settings")
 56:         except Exception as e:
 57:             logger.error(f"Error setting up configuration: {e}")
 58:             self._setup_default_config()
 59: 
 60:     def _setup_default_config(self):
 61:         logger.warning("Using default configuration settings")
 62:         self.language = 'python'
 63:         self.indent_size = 4
 64:         self.max_line_length = 80
 65:         self.typing_speed = {
 66:             'min': 0.03,
 67:             'max': 0.07,
 68:             'line_break': (0.5, 1.0),
 69:             'mistake_rate': 0.07,
 70:         }
 71: 
 72:     def _get_config_path(self) -> str:
 73:         from .path_utils import get_resource_path
 74:         config_path = get_resource_path(self.app, 'config.json')
 75:         if not os.path.exists(config_path):
 76:             logger.error(f"Config file not found at {config_path}")
 77:             raise FileNotFoundError(f"Config file not found at {config_path}")
 78:         return config_path
 79: 
 80:     def _get_code_files(self) -> list:
 81: 
 82:         from .path_utils import get_resource_path
 83:         code_dir = get_resource_path(self.app, 'code')
 84:         if os.path.isdir(code_dir):
 85:             files = [os.path.join(code_dir, f) for f in os.listdir(code_dir) if f.endswith(".txt")]
 86:             if not files:
 87:                 logger.warning(f"No .txt files found in {code_dir}")
 88:             return files
 89:         else:
 90:             logger.warning(f"Code directory not found: {code_dir}")
 91:             return []
 92: 
 93:     def _load_config(self) -> dict:
 94:         try:
 95:             with open(self._get_config_path(), 'r') as f:
 96:                 config = json.load(f)
 97:                 logger.info("Successfully loaded configuration")
 98:                 return config
 99:         except Exception as e:
100:             logger.error(f"Error loading config: {e}")
101:             raise
102: 
103:     def load_config(self):
104:         try:
105:             config_path = os.path.join(os.path.dirname(__file__), 'resources', 'config.json')
106:             logger.info(f"Loading config from: {config_path}")
107:             with open(config_path, "r") as f:
108:                 config = json.load(f)
109:                 code_config = config.get('code', {})
110:                 self.language = code_config.get("language", "unknown")
111:                 self.indent_size = code_config.get("indent_size", 4)
112:                 self.max_line_length = code_config.get("max_line_length", 80)
113:         except Exception as e:
114:             logger.error(f"Error loading config: {e}")
115:             self.language = "unknown"
116:             self.indent_size = 4
117:             self.max_line_length = 80
118: 
119:     async def simulate_command_tab(self):
120: 
121:         try:
122:             if sys.platform == 'darwin':
123:                 pyautogui.hotkey('command', 'tab')
124:             elif sys.platform == 'win32':
125:                 pyautogui.hotkey('alt', 'tab')
126:             else:
127:                 pyautogui.hotkey('alt', 'tab')
128: 
129:             logger.info("Pressed Command+Tab / Alt+Tab")
130:             await asyncio.sleep(0.5)
131:         except Exception as e:
132:             logger.error(f"Error simulating Command+Tab: {e}")
133: 
134:     def _configure_pyautogui(self):
135:         try:
136:             import pyautogui
137:             pyautogui.FAILSAFE = True
138:             pyautogui.PAUSE = 0.1
139:             logger.info(f"PyAutoGUI initialized. Screen size: {pyautogui.size()}")
140:         except Exception as e:
141:             logger.error(f"Failed to initialize PyAutoGUI: {e}")
142:             self.text_box.value += f"‚ö†Ô∏è Warning: Failed to initialize PyAutoGUI: {e}\n"
143: 
144: 
145: 
146:     def get_next_code_file(self) -> Optional[str]:
147: 
148:         if self.code_files:
149:             file_path = self.code_files[self.current_code_index]
150:             self.current_code_index = (self.current_code_index + 1) % len(self.code_files)
151:             return file_path
152:         return None
153: 
154:     def _split_file_into_chunks(self, file_path: str, chunk_size: int = 50) -> list:
155: 
156:         with open(file_path, "r") as f:
157:             lines = f.readlines()
158:         if len(lines) <= chunk_size:
159:             return [lines]
160:         chunks = [lines[i:i + chunk_size] for i in range(0, len(lines), chunk_size)]
161:         logger.info(f"Split file {file_path} into {len(chunks)} chunks")
162:         return chunks
163: 
164:     async def calculate_typing_time(self, file_path: str) -> dict:
165:         try:
166:             with open(file_path, "r") as file:
167:                 lines = file.readlines()
168:             total_chars = sum(len(line.rstrip()) for line in lines)
169:             total_lines = len(lines)
170:             empty_lines = sum(1 for line in lines if not line.strip())
171:             non_empty_lines = total_lines - empty_lines
172: 
173:             avg_char_time = (self.typing_speed["min"] + self.typing_speed["max"]) / 2
174:             char_typing_time = total_chars * avg_char_time
175: 
176:             expected_mistakes = int(total_chars * self.typing_speed["mistake_rate"])
177:             mistake_time = expected_mistakes * (0.2 + 0.1)
178: 
179:             avg_line_break = sum(self.typing_speed["line_break"]) / 2
180:             line_break_time = non_empty_lines * avg_line_break
181:             empty_line_time = empty_lines * (avg_line_break * 0.5)
182: 
183:             total_time = char_typing_time + mistake_time + line_break_time + empty_line_time
184: 
185:             timing_details = {
186:                 "total_time_seconds": round(total_time, 2),
187:                 "total_time_formatted": self._format_time(total_time),
188:                 "breakdown": {
189:                     "characters": {"count": total_chars, "time_seconds": round(char_typing_time, 2)},
190:                     "lines": {"total": total_lines, "empty": empty_lines, "non_empty": non_empty_lines,
191:                               "time_seconds": round(line_break_time + empty_line_time, 2)},
192:                     "expected_mistakes": {"count": expected_mistakes, "time_seconds": round(mistake_time, 2)},
193:                     "typing_speed": {"chars_per_second": round(1 / avg_char_time, 2),
194:                                      "avg_pause_between_lines": round(avg_line_break, 2)},
195:                 },
196:             }
197:             logger.info(f"Estimated typing time: {timing_details['total_time_formatted']}")
198:             self.text_box.value += (
199:                 f"Estimated typing time: {timing_details['total_time_formatted']}\n"
200:                 f"Total characters: {total_chars}\n"
201:                 f"Total lines: {total_lines}\n"
202:                 f"Expected mistakes: {expected_mistakes}\n"
203:             )
204:             return timing_details
205: 
206:         except FileNotFoundError:
207:             logger.error(f"File not found: {file_path}")
208:             self.text_box.value += f"Error: File not found: {file_path}\n"
209:             return None
210:         except Exception as e:
211:             logger.error(f"Error calculating typing time: {e}")
212:             self.text_box.value += f"Error calculating typing time: {e}\n"
213:             return None
214: 
215:     def _format_time(self, seconds: float) -> str:
216:         hours = int(seconds // 3600)
217:         minutes = int((seconds % 3600) // 60)
218:         remaining_seconds = int(seconds % 60)
219:         if hours > 0:
220:             return f"{hours}h {minutes}m {remaining_seconds}s"
221:         elif minutes > 0:
222:             return f"{minutes}m {remaining_seconds}s"
223:         else:
224:             return f"{remaining_seconds}s"
225: 
226: 
227: 
228:     async def simulate_typing(self, file_path: Optional[str] = None):
229: 
230:         logger.debug(f"simulate_typing called with file_path: {file_path}")
231: 
232:         if self.simulation_mode == "Tab Switching Only":
233:             self.text_box.value += "Tab switching only mode selected. Skipping typing simulation...\n"
234:             return
235:         elif self.simulation_mode in ["Typing Only", "Hybrid"]:
236: 
237:             if not file_path:
238:                 logger.error("No file path provided for typing simulation")
239:                 self.text_box.value += "‚ùå Error: No file path provided for typing simulation.\n"
240:                 return
241: 
242:             if not os.path.exists(file_path):
243:                 logger.error(f"File not found: {file_path}")
244:                 self.text_box.value += f"‚ùå Error: File not found: {file_path}\n"
245:                 return
246: 
247:             logger.info(f"Simulating typing with file: {file_path}")
248:             self.text_box.value += f"Typing from file: {os.path.basename(file_path)}\n"
249: 
250: 
251:             chunks = self._split_file_into_chunks(file_path, chunk_size=50)
252:             for i, chunk in enumerate(chunks):
253:                 if not self.loop_flag:
254:                     break
255:                 chunk_text = "".join(chunk)
256:                 await self._simulate_code_typing_from_lines(chunk_text, i)
257:                 await asyncio.sleep(random.uniform(*self.typing_speed["line_break"]))
258:         else:
259:             self.text_box.value += "Unknown simulation mode selected.\n"
260: 
261:     async def _simulate_code_typing_from_lines(self, text: str, chunk_index: int):
262:         lines = text.splitlines(keepends=True)
263:         original_indents = {i: len(line) - len(line.lstrip()) for i, line in enumerate(lines)}
264:         self.text_box.value += f"Typing chunk {chunk_index + 1}...\n"
265:         for i, line in enumerate(lines):
266:             if not self.loop_flag:
267:                 break
268:             line = " " * original_indents.get(i, 0) + line.strip()
269:             if not line:
270:                 pyautogui.press("enter")
271:                 await asyncio.sleep(random.uniform(*self.typing_speed["line_break"]))
272:                 continue
273:             await self._type_line_with_simulation(line, i)
274:             await asyncio.sleep(random.uniform(*self.typing_speed["line_break"]))
275: 
276:     async def _type_line_with_simulation(self, line: str, line_num: int):
277:         if self.formatter:
278:             line = self.formatter.format_line(line)
279:         for char in line:
280:             if not self.loop_flag:
281:                 break
282:             if random.random() < self.typing_speed["mistake_rate"]:
283:                 await self._simulate_typing_mistake(char)
284:             self._type_character(char)
285:             await asyncio.sleep(random.uniform(self.typing_speed["min"], self.typing_speed["max"]))
286:         pyautogui.press("enter")
287:         logger.info(f"Typed line: {line}")
288: 
289:     async def _simulate_typing_mistake(self, correct_char: str):
290:         wrong_char = random.choice("abcdefghijklmnopqrstuvwxyz")
291:         pyautogui.write(wrong_char)
292:         await asyncio.sleep(0.2)
293:         pyautogui.press("backspace")
294:         await asyncio.sleep(0.1)
295: 
296:     def _type_character(self, char: str):
297:         if char == "\t":
298:             pyautogui.press("tab")
299:         elif char == "\n":
300:             pyautogui.press("enter")
301:         else:
302:             pyautogui.write(char)
303: 
304:     def switch_window(self):
305:         app = self.app_switcher.get_random_running_app()
306:         if app:
307:             if self.app_switcher.focus_application(app):
308:                 self.text_box.value += f"Switched to {app['name']}\n"
309:                 logger.info(f"Switched to {app['name']}")
310:             else:
311:                 self.text_box.value += f"Failed to switch to {app['name']}\n"
312:                 logger.error(f"Failed to switch to {app['name']}")
313:         else:
314:             self.text_box.value += "No configured applications running\n"
315:             logger.warning("No configured applications running")
316: 
317:     async def _simulate_random_actions(self):
318:         while self.loop_flag:
319:             actions = [
320:                 self._random_cursor_move,
321:                 self._random_scroll,
322:                 self._middle_click,
323:                 self._window_switch_action,
324:             ]
325:             for action in actions:
326:                 if not self.loop_flag:
327:                     break
328:                 await action()
329:             await asyncio.sleep(random.uniform(0.3, 0.7))
330: 
331:     async def _random_cursor_move(self):
332:         x = random.randint(100, 1000)
333:         y = random.randint(100, 1000)
334:         pyautogui.moveTo(x, y, duration=0.5)
335:         logger.info(f"Moved cursor to ({x}, {y})")
336: 
337:     async def _random_scroll(self):
338:         scroll_amount = random.randint(-100, 100)
339:         pyautogui.scroll(scroll_amount)
340:         logger.info(f"Scrolled {scroll_amount}")
341:         await asyncio.sleep(0.5)
342:         pyautogui.move(100, 50, duration=0.5)
343:         logger.info("Moved mouse relatively by (100, 50).")
344:         await asyncio.sleep(0.5)
345:         pyautogui.move(-50, -25, duration=0.5)
346:         logger.info("Moved mouse relatively by (-50, -25).")
347:         await asyncio.sleep(0.5)
348: 
349:     async def _middle_click(self):
350:         if random.random() < 0.3:
351:             pyautogui.click(button="middle")
352:             logger.info("Middle clicked")
353: 
354:     async def _window_switch_action(self):
355:         if random.random() < 0.2:
356:             self.switch_window()
357:             await asyncio.sleep(0.5)
358: 
359:     async def _cleanup_simulation(self):
360:         await asyncio.sleep(0.5)
361: 
362:     def _handle_simulation_end(self):
363:         self.loop_flag = False
364:         self.mouse_controller.stop()
365:         self.text_box.value += "Simulation ended\n"
366:         logger.info("Simulation ended")
367: 
368:     async def simulate_mouse_and_command_tab(self, duration=10):
369: 
370:         if not self.loop_flag:
371:             return
372: 
373:         self.text_box.value += "üñ±Ô∏è Simulating mouse movements and Command+Tab...\n"
374:         logger.info("Starting mouse and Command+Tab simulation")
375: 
376:         start_time = time.time()
377: 
378:         try:
379: 
380:             self.mouse_controller.start(min_interval=1.0, max_interval=3.0)
381: 
382: 
383:             while self.loop_flag and (time.time() - start_time < duration):
384: 
385:                 for _ in range(random.randint(1, 3)):
386:                     if not self.loop_flag:
387:                         break
388:                     await self._random_cursor_move()
389:                     await asyncio.sleep(random.uniform(0.5, 1.5))
390: 
391: 
392:                 if random.random() < 0.7:
393:                     await self.simulate_command_tab()
394: 
395: 
396:                 await asyncio.sleep(random.uniform(1.0, 2.0))
397: 
398:         finally:
399: 
400:             self.mouse_controller.stop()
401:             logger.info("Mouse and Command+Tab simulation completed")

================
File: src/codesimulator/app_switcher.py
================
  1: import sys
  2: import subprocess
  3: from typing import Optional, List, Dict
  4: import random
  5: from .logging_config import logger
  6: 
  7: 
  8: class AppSwitcher:
  9: 
 10: 
 11:     def __init__(self, config):
 12: 
 13:         self.config = config
 14:         self.platform = sys.platform
 15:         self._quartz = None
 16:         self._win32gui = None
 17:         self._win32process = None
 18:         self._display = None
 19:         self._setup_platform_handler()
 20: 
 21:     def _setup_platform_handler(self):
 22: 
 23:         try:
 24:             if self.platform == 'darwin':
 25:                 self._setup_macos_handler()
 26:             elif self.platform == 'win32':
 27:                 self._setup_windows_handler()
 28:             else:
 29:                 self._setup_linux_handler()
 30:         except Exception as e:
 31:             logger.error(f"Failed to setup platform handler: {e}")
 32:             raise RuntimeError(f"Platform setup failed: {e}")
 33: 
 34:     def _setup_macos_handler(self):
 35: 
 36:         try:
 37:             import Quartz
 38:             self._quartz = Quartz
 39:         except ImportError as e:
 40:             logger.error(f"Failed to import Quartz module for macOS: {e}")
 41:             raise ImportError("Quartz module is required for macOS support")
 42: 
 43:     def _setup_windows_handler(self):
 44: 
 45:         try:
 46:             import win32gui
 47:             import win32process
 48:             self._win32gui = win32gui
 49:             self._win32process = win32process
 50:         except ImportError as e:
 51:             logger.error(f"Failed to import win32gui/win32process modules: {e}")
 52:             raise ImportError("win32gui and win32process modules are required for Windows support")
 53: 
 54:     def _setup_linux_handler(self):
 55: 
 56:         try:
 57:             import Xlib.display
 58:             self._display = Xlib.display.Display()
 59:         except ImportError as e:
 60:             logger.error(f"Failed to import Xlib module: {e}")
 61:             raise ImportError("Xlib module is required for Linux support")
 62: 
 63:     def _remove_duplicates(self, apps: List[Dict]) -> List[Dict]:
 64: 
 65:         seen = set()
 66:         unique_apps = []
 67:         for app in apps:
 68: 
 69:             identifier = tuple(sorted((k, str(v)) for k, v in app.items()))
 70:             if identifier not in seen:
 71:                 seen.add(identifier)
 72:                 unique_apps.append(app)
 73:         return unique_apps
 74: 
 75:     def get_running_applications(self) -> List[Dict]:
 76: 
 77:         if self.platform == 'darwin':
 78:             return self._get_running_applications_macos()
 79:         elif self.platform == 'win32':
 80:             return self._get_running_applications_windows()
 81:         else:
 82:             return self._get_running_applications_linux()
 83: 
 84:     def _get_running_applications_macos(self) -> List[Dict]:
 85: 
 86:         running_apps = []
 87:         try:
 88:             window_list = self._quartz.CGWindowListCopyWindowInfo(
 89:                 self._quartz.kCGWindowListOptionOnScreenOnly |
 90:                 self._quartz.kCGWindowListExcludeDesktopElements,
 91:                 self._quartz.kCGNullWindowID
 92:             )
 93: 
 94:             if window_list:
 95:                 window_list = list(window_list)
 96: 
 97:             for app in self.config.get_applications():
 98:                 app_name = app.get('process_name', '')
 99:                 bundle_id = app.get('bundle_id', '')
100: 
101:                 for window in window_list:
102:                     owner = window.get(self._quartz.kCGWindowOwnerName, '')
103:                     owner_bundle = window.get('kCGWindowOwnerBundleID', '')
104: 
105:                     if (owner and owner == app_name) or \
106:                             (bundle_id and owner_bundle == bundle_id):
107:                         running_apps.append(app.copy())
108:                         break
109: 
110:         except Exception as e:
111:             logger.error(f"Error getting macOS running applications: {e}")
112:             return []
113: 
114:         return self._remove_duplicates(running_apps)
115: 
116:     def _get_running_applications_windows(self) -> List[Dict]:
117: 
118:         running_apps = []
119:         try:
120:             def callback(hwnd, apps):
121:                 if not self._win32gui.IsWindowVisible(hwnd):
122:                     return True
123: 
124:                 try:
125:                     _, pid = self._win32process.GetWindowThreadProcessId(hwnd)
126:                     class_name = self._win32gui.GetClassName(hwnd)
127: 
128:                     for app in self.config.get_applications():
129:                         if class_name == app.get('window_class'):
130:                             apps.append(app.copy())
131:                 except Exception as e:
132:                     logger.debug(f"Error processing window {hwnd}: {e}")
133:                 return True
134: 
135:             self._win32gui.EnumWindows(callback, running_apps)
136:         except Exception as e:
137:             logger.error(f"Error getting Windows running applications: {e}")
138:             return []
139: 
140:         return self._remove_duplicates(running_apps)
141: 
142:     def _get_running_applications_linux(self) -> List[Dict]:
143: 
144:         running_apps = []
145:         try:
146:             root = self._display.screen().root
147:             window_ids = root.get_full_property(
148:                 self._display.intern_atom('_NET_CLIENT_LIST'),
149:                 self._display.intern_atom('WINDOW')
150:             ).value
151: 
152:             for window_id in window_ids:
153:                 window = self._display.create_resource_object('window', window_id)
154:                 try:
155:                     window_class = window.get_wm_class()
156:                     if window_class:
157:                         for app in self.config.get_applications():
158:                             if app.get('window_class') in window_class:
159:                                 running_apps.append(app.copy())
160:                 except Exception as e:
161:                     logger.debug(f"Error processing window {window_id}: {e}")
162:                     continue
163: 
164:         except Exception as e:
165:             logger.error(f"Error getting Linux running applications: {e}")
166:             return []
167: 
168:         return self._remove_duplicates(running_apps)
169: 
170:     def get_random_running_app(self) -> Optional[Dict]:
171: 
172:         running_apps = self.get_running_applications()
173:         return random.choice(running_apps) if running_apps else None
174: 
175:     def focus_application(self, app_info: Dict) -> bool:
176: 
177:         if not app_info:
178:             logger.error("Cannot focus: app_info is None or empty")
179:             return False
180: 
181:         try:
182:             if self.platform == 'darwin':
183:                 app_name = app_info.get("name")
184:                 if not app_name:
185:                     raise ValueError("No application name provided")
186:                 subprocess.run(
187:                     ['osascript', '-e', f'tell application "{app_name}" to activate'],
188:                     check=True,
189:                     capture_output=True,
190:                     text=True
191:                 )
192: 
193:             elif self.platform == 'win32':
194:                 window_class = app_info.get('window_class')
195:                 if not window_class:
196:                     raise ValueError("No window class provided")
197: 
198:                 def callback(hwnd, class_name):
199:                     try:
200:                         if (self._win32gui.IsWindowVisible(hwnd) and
201:                                 self._win32gui.GetClassName(hwnd) == class_name):
202:                             self._win32gui.SetForegroundWindow(hwnd)
203:                             return False
204:                     except Exception as e:
205:                         logger.error(f"Error setting foreground window: {e}")
206:                     return True
207: 
208:                 self._win32gui.EnumWindows(callback, window_class)
209: 
210:             else:
211:                 app_name = app_info.get("name")
212:                 if not app_name:
213:                     raise ValueError("No application name provided")
214:                 subprocess.run(
215:                     ['wmctrl', '-a', app_name],
216:                     check=True,
217:                     capture_output=True,
218:                     text=True
219:                 )
220: 
221:             return True
222: 
223:         except subprocess.CalledProcessError as e:
224:             logger.error(f"Command failed with return code {e.returncode}: {e.output}")
225:             return False
226:         except Exception as e:
227:             logger.error(f"Error focusing application {app_info.get('name', 'unknown')}: {e}")
228:             return False

================
File: src/codesimulator/app.py
================
   1: import asyncio
   2: import os
   3: import json
   4: import tempfile
   5: import platform
   6: import random
   7: import subprocess
   8: import sys
   9: from typing import Optional
  10: import toga
  11: from toga.style import Pack
  12: from toga.style.pack import COLUMN, ROW, CENTER, LEFT, RIGHT
  13: from toga.colors import rgb, rgba
  14: from .actions import ActionSimulator
  15: from .key_handler import GlobalKeyHandler
  16: from .logging_config import get_log_path, setup_file_logging, logger
  17: from .path_utils import log_environment_info, get_log_path
  18: 
  19: log_environment_info()
  20: 
  21: 
  22: class CodeSimulator(toga.App):
  23:     def __init__(self):
  24:         super().__init__(
  25:             formal_name="Code Simulator",
  26:             app_id="com.example.codesimulator"
  27:         )
  28: 
  29:         self.selected_file = None
  30:         self.current_view = "simulation"
  31: 
  32:     def shutdown(self):
  33: 
  34:         logger.info("Application shutting down, cleaning up resources...")
  35: 
  36: 
  37:         if self.action_simulator.loop_flag:
  38:             self.action_simulator.loop_flag = False
  39: 
  40: 
  41:         if hasattr(self, 'key_handler'):
  42:             self.key_handler.cleanup()
  43: 
  44: 
  45:         logger.info("Cleanup completed, application shutting down")
  46: 
  47: 
  48:     async def show_debug_info(self, widget):
  49:         info = {
  50:             "OS": platform.system(),
  51:             "OS Version": platform.version(),
  52:             "Python Version": platform.python_version(),
  53:             "App Directory": os.path.dirname(os.path.abspath(__file__)),
  54:             "Current Directory": os.getcwd(),
  55:             "Log File": get_log_path(),
  56:             "Is Packaged": getattr(sys, 'frozen', False),
  57:             "Executable": sys.executable
  58:         }
  59: 
  60:         self.console.value = "--- Debug Information ---\n\n"
  61:         for key, value in info.items():
  62:             self.console.value += f"{key}: {value}\n"
  63: 
  64:         log_environment_info()
  65:         self.console.value += "\nDetailed debug information has been logged to the log file.\n"
  66: 
  67:     async def view_console_logs(self, widget):
  68:         try:
  69:             if platform.system() == "Darwin":
  70:                 process = subprocess.Popen(
  71:                     ["log", "show", "--predicate", "process == 'Code Simulator'", "--last", "1h"],
  72:                     stdout=subprocess.PIPE,
  73:                     stderr=subprocess.PIPE,
  74:                     text=True
  75:                 )
  76:                 stdout, stderr = process.communicate(timeout=5)
  77: 
  78:                 if stdout:
  79:                     self.console.value = "Recent Console Logs:\n\n" + stdout
  80:                 else:
  81:                     self.console.value = "No recent console logs found.\n"
  82:                     if stderr:
  83:                         self.console.value += f"Error: {stderr}\n"
  84:             else:
  85:                 self.console.value = "Console log viewing only supported on macOS."
  86:         except Exception as e:
  87:             self.console.value = f"Error viewing console logs: {e}"
  88: 
  89:     async def view_logs(self, widget):
  90:         setup_file_logging()
  91:         log_path = get_log_path()
  92: 
  93:         self.console.value = "Log Information\n"
  94:         self.console.value += "=============\n\n"
  95:         self.console.value += f"Log file location: {log_path}\n\n"
  96: 
  97:         logger.info("Test log message from View Logs button")
  98: 
  99:         if not os.path.exists(log_path):
 100:             self.console.value += f"‚ùå Log file still not found after write attempt!\n\n"
 101: 
 102:             try:
 103:                 log_dir = os.path.dirname(log_path)
 104:                 test_file_path = os.path.join(log_dir, "test_write.txt")
 105:                 with open(test_file_path, 'w') as f:
 106:                     f.write("Test write")
 107:                 self.console.value += f"‚úì Successfully created test file at: {test_file_path}\n"
 108:                 os.remove(test_file_path)
 109:             except Exception as e:
 110:                 self.console.value += f"‚ùå Could not write test file: {e}\n"
 111:                 self.console.value += "This suggests a permissions issue or the directory doesn't exist\n"
 112: 
 113:             self.console.value += "\nEnvironment Information:\n"
 114:             self.console.value += f"Working directory: {os.getcwd()}\n"
 115:             self.console.value += f"Home directory: {os.path.expanduser('~')}\n"
 116:             self.console.value += f"App directory: {os.path.dirname(__file__)}\n"
 117:             self.console.value += f"Python executable: {sys.executable}\n"
 118:             self.console.value += f"Is packaged: {getattr(sys, 'frozen', False)}\n"
 119: 
 120:             self.console.value += "\nTry looking for logs in these locations:\n"
 121:             self.console.value += f"1. {os.path.join(os.path.expanduser('~'), 'Library', 'Logs', 'CodeSimulator')}\n"
 122:             self.console.value += f"2. {tempfile.gettempdir()}\n"
 123: 
 124:             return
 125: 
 126:         file_size = os.path.getsize(log_path)
 127:         last_modified = os.path.getmtime(log_path)
 128:         import datetime
 129:         mod_time = datetime.datetime.fromtimestamp(last_modified).strftime('%Y-%m-%d %H:%M:%S')
 130: 
 131:         self.console.value += f"Log file size: {file_size} bytes\n"
 132:         self.console.value += f"Last modified: {mod_time}\n\n"
 133: 
 134:         try:
 135:             with open(log_path, 'r') as f:
 136:                 if file_size > 10000:
 137:                     self.console.value += f"Log file is large. Showing last portion...\n\n"
 138:                     f.seek(max(0, file_size - 10000))
 139:                     f.readline()
 140:                     content = f.read()
 141:                 else:
 142:                     content = f.read()
 143: 
 144:             self.console.value += "Log Content:\n"
 145:             self.console.value += "===========\n\n"
 146:             self.console.value += content
 147: 
 148:         except Exception as e:
 149:             self.console.value += f"‚ùå Error reading log file: {e}\n"
 150: 
 151:     def startup(self):
 152:         from .logging_config import setup_file_logging
 153:         setup_file_logging()
 154: 
 155:         self.setup_ui()
 156:         self.setup_components()
 157:         logger.info("Application started successfully.")
 158: 
 159:     def setup_colors(self):
 160:         self.colors = {
 161:             'primary': rgb(0, 122, 255),
 162:             'secondary': rgb(0, 163, 92),
 163:             'danger': rgb(255, 45, 85),
 164:             'background': rgb(34, 34, 34),
 165:             'card': rgb(34, 34, 50),
 166:             'text': rgb(230, 230, 230),
 167:             'text_light': rgb(160, 160, 160),
 168:             'menu_bg': rgb(24, 24, 24),
 169:             'menu_text': rgb(255, 255, 255),
 170:             'menu_selected': rgb(70, 70, 70),
 171:             'toolbar': rgb(24, 24, 24),
 172:             'toolbar_text': rgb(255, 255, 255),
 173:         }
 174: 
 175:     def setup_ui(self):
 176:         self.setup_colors()
 177: 
 178: 
 179:         main_box = toga.Box(style=Pack(direction=COLUMN, flex=1, background_color=self.colors['background']))
 180: 
 181: 
 182:         top_bar = toga.Box(style=Pack(
 183:             direction=ROW,
 184:             padding=(10, 15),
 185:             height=50,
 186:             background_color=self.colors['toolbar'],
 187:             alignment=CENTER
 188:         ))
 189: 
 190: 
 191:         app_title = toga.Label(
 192:             "Code Simulator",
 193:             style=Pack(font_size=16, font_weight="bold", color=self.colors['toolbar_text'], padding_right=20)
 194:         )
 195: 
 196: 
 197:         self.start_button = toga.Button(
 198:             "‚ñ∂",
 199:             on_press=self.start_simulation,
 200:             style=Pack(width=40, height=30, background_color=self.colors['primary'], color="white", font_size=14),
 201:         )
 202:         self.stop_button = toga.Button(
 203:             "‚èπ",
 204:             on_press=self.stop_simulation,
 205:             enabled=False,
 206:             style=Pack(width=40, height=30, background_color=self.colors['danger'], color="white", font_size=14),
 207:         )
 208: 
 209: 
 210:         self.status_label = toga.Label(
 211:             "Ready",
 212:             style=Pack(font_size=12, color=self.colors['toolbar_text'], padding_left=20, flex=1)
 213:         )
 214: 
 215:         top_bar.add(app_title)
 216:         top_bar.add(self.start_button)
 217:         top_bar.add(self.stop_button)
 218:         top_bar.add(self.status_label)
 219: 
 220: 
 221:         inner_box = toga.Box(style=Pack(direction=ROW, flex=1))
 222:         self.side_menu = self.create_side_menu()
 223:         self.content_container = toga.Box(style=Pack(
 224:             direction=COLUMN,
 225:             flex=1,
 226:             padding=20,
 227:             background_color=self.colors['background']
 228:         ))
 229: 
 230:         inner_box.add(self.side_menu)
 231:         inner_box.add(self.content_container)
 232: 
 233: 
 234:         self.simulation_view = self.create_simulation_view()
 235:         self.configuration_view = self.create_configuration_view()
 236:         self.logs_view = self.create_logs_view()
 237:         self.about_view = self.create_about_view()
 238:         self.show_view("simulation")
 239: 
 240:         main_box.add(top_bar)
 241:         main_box.add(inner_box)
 242: 
 243:         self.main_window = toga.MainWindow(title=self.formal_name)
 244:         self.main_window.content = main_box
 245:         self.main_window.show()
 246: 
 247:     def create_side_menu(self):
 248:         side_menu = toga.Box(style=Pack(
 249:             direction=COLUMN,
 250:             width=60,
 251:             background_color=self.colors['menu_bg'],
 252:             padding_top=10
 253:         ))
 254: 
 255:         menu_options = [
 256:             ("simulation", "Simulation", "‚å®Ô∏è"),
 257:             ("configuration", "Configuration", "‚öôÔ∏è"),
 258:             ("logs", "Logs", "üìä"),
 259:             ("about", "About", "‚ÑπÔ∏è")
 260:         ]
 261:         self.menu_items = {}
 262: 
 263:         for item_id, label, icon in menu_options:
 264:             menu_item = toga.Button(
 265:                 icon,
 266:                 on_press=lambda widget, vid=item_id: self.show_view(vid),
 267:                 style=Pack(
 268:                     width=60,
 269:                     height=60,
 270:                     font_size=20,
 271:                     background_color=self.colors['menu_bg'],
 272:                     color=self.colors['menu_text'],
 273:                     alignment=CENTER
 274:                 )
 275:             )
 276: 
 277:             if item_id == self.current_view:
 278:                 menu_item.style.background_color = self.colors['menu_selected']
 279:             self.menu_items[item_id] = menu_item
 280:             side_menu.add(menu_item)
 281: 
 282:         return side_menu
 283: 
 284:     def create_menu_item(self, item_id, label, icon):
 285: 
 286: 
 287:         menu_item = toga.Box(style=Pack(
 288:             direction=ROW,
 289:             padding=(12, 15),
 290:             alignment=CENTER,
 291:         ))
 292: 
 293: 
 294:         icon_label = toga.Label(
 295:             icon,
 296:             style=Pack(
 297:                 font_size=16,
 298:                 color=self.colors['menu_text'],
 299:                 width=25,
 300:                 text_align=CENTER
 301:             )
 302:         )
 303: 
 304: 
 305:         text_label = toga.Label(
 306:             label,
 307:             style=Pack(
 308:                 font_size=14,
 309:                 color=self.colors['menu_text'],
 310:                 padding_left=10,
 311:                 text_align=LEFT,
 312:                 flex=1
 313:             )
 314:         )
 315: 
 316:         menu_item.add(icon_label)
 317:         menu_item.add(text_label)
 318: 
 319: 
 320:         button = toga.Button(
 321:             "",
 322:             on_press=lambda widget: self.show_view(item_id),
 323:             style=Pack(
 324:                 padding=0,
 325:                 flex=1
 326:             )
 327:         )
 328: 
 329:         button.style.background_color = rgba(0, 0, 0, 0)
 330: 
 331:         menu_item.add(button)
 332: 
 333: 
 334:         if item_id == self.current_view:
 335:             menu_item.style.background_color = self.colors['menu_selected']
 336: 
 337:         return menu_item
 338: 
 339:     def show_view(self, view_name):
 340:         for child in self.content_container.children:
 341:             self.content_container.remove(child)
 342: 
 343:         # Update menu item styling
 344:         for item_id, menu_item in self.menu_items.items():
 345:             menu_item.style.background_color = (
 346:                 self.colors['menu_selected'] if item_id == view_name else self.colors['menu_bg']
 347:             )
 348: 
 349:         self.current_view = view_name
 350:         if view_name == "simulation":
 351:             self.content_container.add(self.simulation_view)
 352:         elif view_name == "configuration":
 353:             self.content_container.add(self.configuration_view)
 354:         elif view_name == "logs":
 355:             self.content_container.add(self.logs_view)
 356:         elif view_name == "about":
 357:             self.content_container.add(self.about_view)
 358: 
 359:     def create_simulation_view(self):
 360:         simulation_view = toga.Box(style=Pack(
 361:             direction=COLUMN,
 362:             background_color=self.colors['card'],
 363:             padding=20,
 364:         ))
 365: 
 366:         # Mode Selector
 367:         mode_box = toga.Box(style=Pack(direction=ROW, padding_bottom=15))
 368:         mode_label = toga.Label("Mode:", style=Pack(font_size=14, color=self.colors['text'], width=100))
 369:         self.mode_selector = toga.Selection(
 370:             items=["Typing Only", "Tab Switching Only", "Hybrid", "Mouse and Command+Tab"],
 371:             style=Pack(flex=1, height=35, background_color=self.colors['card'])
 372:         )
 373:         mode_box.add(mode_label)
 374:         mode_box.add(self.mode_selector)
 375: 
 376:         # File Selection
 377:         file_box = toga.Box(style=Pack(direction=ROW, padding_bottom=15))
 378:         self.file_display = toga.Label(
 379:             "Using default resources/code files",
 380:             style=Pack(flex=1, font_size=12, color=self.colors['text_light'])
 381:         )
 382:         choose_button = toga.Button(
 383:             "Choose File",
 384:             on_press=self.choose_file,
 385:             style=Pack(width=120, height=35, background_color=self.colors['primary'], color="white")
 386:         )
 387:         file_box.add(self.file_display)
 388:         file_box.add(choose_button)
 389: 
 390:         # Console
 391:         self.console = toga.MultilineTextInput(
 392:             readonly=True,
 393:             style=Pack(flex=1, padding_top=10,
 394:                        #background_color=self.colors['card']
 395:                        )
 396:         )
 397: 
 398:         simulation_view.add(mode_box)
 399:         simulation_view.add(file_box)
 400:         simulation_view.add(self.console)
 401:         return simulation_view
 402: 
 403:     def create_configuration_view(self):
 404: 
 405:         configuration_view = toga.Box(style=Pack(
 406:             direction=COLUMN,
 407:             background_color=self.colors['background'],
 408:             padding=(20, 20),
 409:             flex=1
 410:         ))
 411: 
 412:         # Top toolbar
 413:         toolbar = toga.Box(style=Pack(
 414:             direction=ROW,
 415:             padding=(15, 10),
 416:             background_color=self.colors['primary'],
 417:             alignment=CENTER
 418:         ))
 419: 
 420:         toolbar_title = toga.Label(
 421:             "Configuration",
 422:             style=Pack(
 423:                 font_size=16,
 424:                 font_weight="bold",
 425:                 color=self.colors['toolbar_text'],
 426:                 flex=1
 427:             )
 428:         )
 429:         toolbar.add(toolbar_title)
 430: 
 431:         # Save configuration button
 432:         save_config_button = toga.Button(
 433:             "Save Settings",
 434:             on_press=self.save_configuration_direct,
 435:             style=Pack(
 436:                 padding=(10, 15),
 437:                 background_color=self.colors['secondary'],
 438:                 color=self.colors['toolbar_text'],
 439:                 font_weight="bold"
 440:             )
 441:         )
 442:         toolbar.add(save_config_button)
 443: 
 444:         configuration_view.add(toolbar)
 445: 
 446:         # Main content with card design
 447:         content_card = toga.Box(style=Pack(
 448:             direction=COLUMN,
 449:             background_color=self.colors['card'],
 450:             padding=(20, 20),
 451:             flex=1,
 452:         ))
 453: 
 454:         # Create a scroll container to hold all settings
 455:         scroll_container = toga.ScrollContainer(style=Pack(flex=1))
 456:         settings_box = toga.Box(style=Pack(direction=COLUMN, padding=(0, 10)))
 457: 
 458:         # Code Configuration Section
 459:         code_section = toga.Box(style=Pack(
 460:             direction=COLUMN,
 461:             padding=(0, 0, 20, 0)
 462:         ))
 463: 
 464:         code_title = toga.Label(
 465:             "Code Configuration",
 466:             style=Pack(
 467:                 font_size=16,
 468:                 font_weight="bold",
 469:                 color=self.colors['text'],
 470:                 padding_bottom=10
 471:             )
 472:         )
 473:         code_section.add(code_title)
 474: 
 475:         # Language selection
 476:         language_box = toga.Box(style=Pack(
 477:             direction=ROW,
 478:             padding=(0, 0, 10, 0),
 479:             alignment=CENTER
 480:         ))
 481: 
 482:         language_label = toga.Label(
 483:             "Language:",
 484:             style=Pack(
 485:                 width=150,
 486:                 color=self.colors['text']
 487:             )
 488:         )
 489: 
 490:         self.language_input = toga.Selection(
 491:             items=["python", "java", "php"],
 492:             value="python",
 493:             style=Pack(
 494:                 flex=1,
 495:                 padding=(5, 5)
 496:             )
 497:         )
 498: 
 499:         language_box.add(language_label)
 500:         language_box.add(self.language_input)
 501:         code_section.add(language_box)
 502: 
 503:         # Indent size
 504:         indent_box = toga.Box(style=Pack(
 505:             direction=ROW,
 506:             padding=(0, 0, 10, 0),
 507:             alignment=CENTER
 508:         ))
 509: 
 510:         indent_label = toga.Label(
 511:             "Indent Size:",
 512:             style=Pack(
 513:                 width=150,
 514:                 color=self.colors['text']
 515:             )
 516:         )
 517: 
 518:         self.indent_input = toga.NumberInput(
 519:             min_value=1,
 520:             max_value=8,
 521:             step=1,
 522:             value=4,
 523:             style=Pack(
 524:                 flex=1,
 525:                 padding=(5, 5)
 526:             )
 527:         )
 528: 
 529:         indent_box.add(indent_label)
 530:         indent_box.add(self.indent_input)
 531:         code_section.add(indent_box)
 532: 
 533:         # Max line length
 534:         max_line_box = toga.Box(style=Pack(
 535:             direction=ROW,
 536:             padding=(0, 0, 10, 0),
 537:             alignment=CENTER
 538:         ))
 539: 
 540:         max_line_label = toga.Label(
 541:             "Max Line Length:",
 542:             style=Pack(
 543:                 width=150,
 544:                 color=self.colors['text']
 545:             )
 546:         )
 547: 
 548:         self.max_line_input = toga.NumberInput(
 549:             min_value=40,
 550:             max_value=120,
 551:             step=1,
 552:             value=80,
 553:             style=Pack(
 554:                 flex=1,
 555:                 padding=(5, 5)
 556:             )
 557:         )
 558: 
 559:         max_line_box.add(max_line_label)
 560:         max_line_box.add(self.max_line_input)
 561:         code_section.add(max_line_box)
 562: 
 563:         settings_box.add(code_section)
 564: 
 565:         # Divider
 566:         settings_box.add(toga.Divider(style=Pack(
 567:             padding=(0, 10)
 568:         )))
 569: 
 570:         # Typing Speed Configuration Section
 571:         typing_section = toga.Box(style=Pack(
 572:             direction=COLUMN,
 573:             padding=(0, 0, 20, 0)
 574:         ))
 575: 
 576:         typing_title = toga.Label(
 577:             "Typing Speed Configuration",
 578:             style=Pack(
 579:                 font_size=16,
 580:                 font_weight="bold",
 581:                 color=self.colors['text'],
 582:                 padding_bottom=10
 583:             )
 584:         )
 585:         typing_section.add(typing_title)
 586: 
 587:         # Min typing speed
 588:         min_speed_box = toga.Box(style=Pack(
 589:             direction=ROW,
 590:             padding=(0, 0, 10, 0),
 591:             alignment=CENTER
 592:         ))
 593: 
 594:         min_speed_label = toga.Label(
 595:             "Min Speed (sec):",
 596:             style=Pack(
 597:                 width=150,
 598:                 color=self.colors['text']
 599:             )
 600:         )
 601: 
 602:         self.min_speed_input = toga.NumberInput(
 603:             min_value=0.01,
 604:             max_value=0.5,
 605:             step=0.01,
 606:             value=0.15,
 607:             style=Pack(
 608:                 flex=1,
 609:                 padding=(5, 5)
 610:             )
 611:         )
 612: 
 613:         min_speed_box.add(min_speed_label)
 614:         min_speed_box.add(self.min_speed_input)
 615:         typing_section.add(min_speed_box)
 616: 
 617:         # Max typing speed
 618:         max_speed_box = toga.Box(style=Pack(
 619:             direction=ROW,
 620:             padding=(0, 0, 10, 0),
 621:             alignment=CENTER
 622:         ))
 623: 
 624:         max_speed_label = toga.Label(
 625:             "Max Speed (sec):",
 626:             style=Pack(
 627:                 width=150,
 628:                 color=self.colors['text']
 629:             )
 630:         )
 631: 
 632:         self.max_speed_input = toga.NumberInput(
 633:             min_value=0.01,
 634:             max_value=0.5,
 635:             step=0.01,
 636:             value=0.25,
 637:             style=Pack(
 638:                 flex=1,
 639:                 padding=(5, 5)
 640:             )
 641:         )
 642: 
 643:         max_speed_box.add(max_speed_label)
 644:         max_speed_box.add(self.max_speed_input)
 645:         typing_section.add(max_speed_box)
 646: 
 647:         # Mistake rate
 648:         mistake_box = toga.Box(style=Pack(
 649:             direction=ROW,
 650:             padding=(0, 0, 10, 0),
 651:             alignment=CENTER
 652:         ))
 653: 
 654:         mistake_label = toga.Label(
 655:             "Mistake Rate:",
 656:             style=Pack(
 657:                 width=150,
 658:                 color=self.colors['text']
 659:             )
 660:         )
 661: 
 662:         self.mistake_input = toga.NumberInput(
 663:             min_value=0,
 664:             max_value=0.5,
 665:             step=0.01,
 666:             value=0.09,
 667:             style=Pack(
 668:                 flex=1,
 669:                 padding=(5, 5)
 670:             )
 671:         )
 672: 
 673:         mistake_box.add(mistake_label)
 674:         mistake_box.add(self.mistake_input)
 675:         typing_section.add(mistake_box)
 676: 
 677:         settings_box.add(typing_section)
 678: 
 679:         # Divider
 680:         settings_box.add(toga.Divider(style=Pack(
 681:             padding=(0, 10)
 682:         )))
 683: 
 684:         # Applications Configuration Section
 685:         apps_section = toga.Box(style=Pack(
 686:             direction=COLUMN,
 687:             padding=(0, 0, 20, 0)
 688:         ))
 689: 
 690:         apps_title = toga.Label(
 691:             "Applications Configuration",
 692:             style=Pack(
 693:                 font_size=16,
 694:                 font_weight="bold",
 695:                 color=self.colors['text'],
 696:                 padding_bottom=10
 697:             )
 698:         )
 699:         apps_section.add(apps_title)
 700: 
 701:         # Applications list (placeholder)
 702:         apps_info = toga.Label(
 703:             "Application settings are configured in applications.json.\nThe simulator will switch between these applications during simulation.",
 704:             style=Pack(
 705:                 color=self.colors['text'],
 706:                 padding_bottom=10
 707:             )
 708:         )
 709:         apps_section.add(apps_info)
 710: 
 711:         settings_box.add(apps_section)
 712: 
 713:         # Add the settings box to the scroll container
 714:         scroll_container.content = settings_box
 715:         content_card.add(scroll_container)
 716: 
 717:         # Add content card to the view
 718:         configuration_view.add(content_card)
 719: 
 720:         return configuration_view
 721: 
 722:     def create_logs_view(self):
 723: 
 724:         logs_view = toga.Box(style=Pack(
 725:             direction=COLUMN,
 726:             background_color=self.colors['background'],
 727:             padding=(20, 20),
 728:             flex=1
 729:         ))
 730: 
 731:         # Top toolbar
 732:         toolbar = toga.Box(style=Pack(
 733:             direction=ROW,
 734:             padding=(15, 10),
 735:             background_color=self.colors['primary'],
 736:             alignment=CENTER
 737:         ))
 738: 
 739:         toolbar_title = toga.Label(
 740:             "Logs & Debugging",
 741:             style=Pack(
 742:                 font_size=16,
 743:                 font_weight="bold",
 744:                 color=self.colors['toolbar_text'],
 745:                 flex=1
 746:             )
 747:         )
 748:         toolbar.add(toolbar_title)
 749: 
 750:         logs_view.add(toolbar)
 751: 
 752:         # Main content with card design
 753:         content_card = toga.Box(style=Pack(
 754:             direction=COLUMN,
 755:             background_color=self.colors['card'],
 756:             padding=(20, 20),
 757:             flex=1,
 758:         ))
 759: 
 760:         # Debug buttons
 761:         buttons_box = toga.Box(style=Pack(
 762:             direction=ROW,
 763:             padding=(0, 0, 15, 0)
 764:         ))
 765: 
 766:         view_logs_button = toga.Button(
 767:             "View Application Logs",
 768:             on_press=self.view_logs,
 769:             style=Pack(
 770:                 padding=(10, 15),
 771:                 background_color=self.colors['primary'],
 772:                 color=self.colors['toolbar_text'],
 773:             )
 774:         )
 775: 
 776:         debug_info_button = toga.Button(
 777:             "Show Debug Info",
 778:             on_press=self.show_debug_info,
 779:             style=Pack(
 780:                 padding=(10, 15),
 781:                 background_color=self.colors['primary'],
 782:                 color=self.colors['toolbar_text'],
 783:             )
 784:         )
 785: 
 786:         console_logs_button = toga.Button(
 787:             "View Console Logs",
 788:             on_press=self.view_console_logs,
 789:             style=Pack(
 790:                 padding=(10, 15),
 791:                 background_color=self.colors['primary'],
 792:                 color=self.colors['toolbar_text']
 793:             )
 794:         )
 795: 
 796:         buttons_box.add(view_logs_button)
 797:         buttons_box.add(debug_info_button)
 798:         buttons_box.add(console_logs_button)
 799:         content_card.add(buttons_box)
 800: 
 801:         # Divider
 802:         content_card.add(toga.Divider(style=Pack(
 803:             padding=(10, 0)
 804:         )))
 805: 
 806:         # Log output section
 807:         log_box = toga.Box(style=Pack(
 808:             direction=COLUMN,
 809:             padding=(10, 0, 0, 0),
 810:             flex=1
 811:         ))
 812: 
 813:         log_title = toga.Label(
 814:             "Log Output",
 815:             style=Pack(
 816:                 font_size=16,
 817:                 font_weight="bold",
 818:                 color=self.colors['text'],
 819:                 padding_bottom=10
 820:             )
 821:         )
 822:         log_box.add(log_title)
 823: 
 824:         log_instructions = toga.Label(
 825:             "Click one of the buttons above to view logs or debug information.",
 826:             style=Pack(
 827:                 color=self.colors['text_light'],
 828:                 padding_bottom=10
 829:             )
 830:         )
 831:         log_box.add(log_instructions)
 832: 
 833:         log_console = toga.MultilineTextInput(
 834:             readonly=True,
 835:             style=Pack(
 836:                 flex=1,
 837:                 # background_color=self.colors['card']
 838:             )
 839:         )
 840:         self.console = log_console
 841:         log_box.add(log_console)
 842: 
 843:         content_card.add(log_box)
 844:         logs_view.add(content_card)
 845: 
 846:         return logs_view
 847: 
 848:     def create_about_view(self):
 849: 
 850:         about_view = toga.Box(style=Pack(
 851:             direction=COLUMN,
 852:             background_color=self.colors['background'],
 853:             padding=(20, 20),
 854:             flex=1
 855:         ))
 856: 
 857:         # Top toolbar
 858:         toolbar = toga.Box(style=Pack(
 859:             direction=ROW,
 860:             padding=(15, 10),
 861:             background_color=self.colors['primary'],
 862:             alignment=CENTER
 863:         ))
 864: 
 865:         toolbar_title = toga.Label(
 866:             "About & Help",
 867:             style=Pack(
 868:                 font_size=16,
 869:                 font_weight="bold",
 870:                 color=self.colors['toolbar_text'],
 871:                 flex=1
 872:             )
 873:         )
 874:         toolbar.add(toolbar_title)
 875: 
 876:         about_view.add(toolbar)
 877: 
 878:         # Main content with card design
 879:         content_card = toga.Box(style=Pack(
 880:             direction=COLUMN,
 881:             background_color=self.colors['card'],
 882:             padding=(20, 20),
 883:             flex=1,
 884:         ))
 885: 
 886:         # Create a scroll container for about content
 887:         scroll_container = toga.ScrollContainer(style=Pack(flex=1))
 888:         about_content = toga.Box(style=Pack(direction=COLUMN, padding=(0, 0)))
 889: 
 890:         # App information section
 891:         app_info_box = toga.Box(style=Pack(
 892:             direction=COLUMN,
 893:             padding=(0, 0, 20, 0)
 894:         ))
 895: 
 896:         app_name = toga.Label(
 897:             "Code Simulator",
 898:             style=Pack(
 899:                 font_size=24,
 900:                 font_weight="bold",
 901:                 color=self.colors['text'],
 902:                 padding_bottom=5
 903:             )
 904:         )
 905:         app_info_box.add(app_name)
 906: 
 907:         app_version = toga.Label(
 908:             "Version 0.0.1",
 909:             style=Pack(
 910:                 font_size=14,
 911:                 color=self.colors['text_light'],
 912:                 padding_bottom=10
 913:             )
 914:         )
 915:         app_info_box.add(app_version)
 916: 
 917:         app_description = toga.Label(
 918:             "Code Simulator is a tool for simulating coding activity including typing, window switching, and mouse movements. It's designed to create a realistic coding environment simulation.",
 919:             style=Pack(
 920:                 color=self.colors['text'],
 921:                 padding_bottom=10
 922:             )
 923:         )
 924:         app_info_box.add(app_description)
 925: 
 926:         copyright_label = toga.Label(
 927:             "¬© 2025 rylxes. All rights reserved.",
 928:             style=Pack(
 929:                 font_size=12,
 930:                 color=self.colors['text_light'],
 931:                 padding_bottom=20
 932:             )
 933:         )
 934:         app_info_box.add(copyright_label)
 935: 
 936:         about_content.add(app_info_box)
 937: 
 938:         # Divider
 939:         about_content.add(toga.Divider(style=Pack(
 940:             padding=(0, 10)
 941:         )))
 942: 
 943:         # Help section
 944:         help_box = toga.Box(style=Pack(
 945:             direction=COLUMN,
 946:             padding=(10, 0, 20, 0)
 947:         ))
 948: 
 949:         help_title = toga.Label(
 950:             "How to Use",
 951:             style=Pack(
 952:                 font_size=18,
 953:                 font_weight="bold",
 954:                 color=self.colors['text'],
 955:                 padding_bottom=10
 956:             )
 957:         )
 958:         help_box.add(help_title)
 959: 
 960:         # Help content
 961:         help_sections = [
 962:             ("Simulation Modes", [
 963:                 "Typing Only: Simulates keyboard typing from a code file",
 964:                 "Tab Switching Only: Simulates switching between application windows",
 965:                 "Hybrid: Combines typing and application switching",
 966:                 "Mouse and Command+Tab: Simulates mouse movements and Command+Tab switching"
 967:             ]),
 968:             ("File Selection", [
 969:                 "Use the 'Choose File' button to select a .txt file for typing simulation",
 970:                 "If no file is selected, default files from resources/code directory will be used"
 971:             ]),
 972:             ("Configuration", [
 973:                 "Adjust typing speed, language formatting, and other settings in the Configuration tab",
 974:                 "Application targets for switching can be configured in applications.json"
 975:             ]),
 976:             ("Keyboard Shortcuts", [
 977:                 "‚åò+S: Start Simulation",
 978:                 "‚åò+X: Stop Simulation"
 979:             ])
 980:         ]
 981: 
 982:         for section_title, items in help_sections:
 983:             section_label = toga.Label(
 984:                 section_title,
 985:                 style=Pack(
 986:                     font_size=16,
 987:                     font_weight="bold",
 988:                     color=self.colors['text'],
 989:                     padding=(10, 0, 5, 0)
 990:                 )
 991:             )
 992:             help_box.add(section_label)
 993: 
 994:             for item in items:
 995:                 item_label = toga.Label(
 996:                     "‚Ä¢ " + item,
 997:                     style=Pack(
 998:                         color=self.colors['text'],
 999:                         padding=(0, 0, 5, 15)
1000:                     )
1001:                 )
1002:                 help_box.add(item_label)
1003: 
1004:         about_content.add(help_box)
1005: 
1006:         # Add the about content to the scroll container
1007:         scroll_container.content = about_content
1008:         content_card.add(scroll_container)
1009: 
1010:         # Add content card to the view
1011:         about_view.add(content_card)
1012: 
1013:         return about_view
1014: 
1015:     def load_configuration_values(self):
1016: 
1017:         try:
1018:             # Get configuration path
1019:             config_path = self.action_simulator._get_config_path()
1020: 
1021:             # Read configuration file
1022:             with open(config_path, 'r') as f:
1023:                 config = json.load(f)
1024: 
1025:             # Set code configuration values
1026:             code_config = config.get('code', {})
1027:             self.language_input.value = code_config.get('language', 'python')
1028:             self.indent_input.value = code_config.get('indent_size', 4)
1029:             self.max_line_input.value = code_config.get('max_line_length', 80)
1030: 
1031:             # Set typing speed configuration values
1032:             typing_config = config.get('typing_speed', {})
1033:             self.min_speed_input.value = typing_config.get('min', 0.03)
1034:             self.max_speed_input.value = typing_config.get('max', 0.07)
1035:             self.mistake_input.value = typing_config.get('mistake_rate', 0.07)
1036: 
1037:             logger.info("Configuration values loaded successfully")
1038:         except Exception as e:
1039:             logger.error(f"Error loading configuration values: {e}")
1040:             self.console.value = f"Error loading configuration: {e}\n"
1041: 
1042:     async def save_configuration_direct(self, widget):
1043: 
1044:         try:
1045:             # Get configuration path
1046:             config_path = self.action_simulator._get_config_path()
1047: 
1048:             # Read current configuration
1049:             with open(config_path, 'r') as f:
1050:                 config = json.load(f)
1051: 
1052:             # Update code configuration
1053:             if 'code' not in config:
1054:                 config['code'] = {}
1055: 
1056:             config['code']['language'] = self.language_input.value
1057:             config['code']['indent_size'] = self.indent_input.value
1058:             config['code']['max_line_length'] = self.max_line_input.value
1059: 
1060:             # Update typing speed configuration
1061:             if 'typing_speed' not in config:
1062:                 config['typing_speed'] = {}
1063: 
1064:             config['typing_speed']['min'] = self.min_speed_input.value
1065:             config['typing_speed']['max'] = self.max_speed_input.value
1066:             config['typing_speed']['mistake_rate'] = self.mistake_input.value
1067: 
1068:             # Preserve line_break if it exists
1069:             if 'line_break' not in config['typing_speed']:
1070:                 config['typing_speed']['line_break'] = [0.5, 1.0]
1071: 
1072:             # Write updated configuration
1073:             with open(config_path, 'w') as f:
1074:                 json.dump(config, f, indent=4)
1075: 
1076:             # Reload configuration in action simulator
1077:             self.action_simulator.config = self.action_simulator._load_config()
1078:             self.action_simulator._setup_from_config()
1079: 
1080:             # Show success message
1081:             self.console.value = "‚úÖ Configuration saved and reloaded successfully.\n"
1082:             self.status_label.text = "Configuration saved"
1083:             logger.info("Configuration updated successfully")
1084: 
1085:         except Exception as e:
1086:             self.console.value = f"‚ùå Error saving configuration: {e}\n"
1087:             logger.error(f"Error saving configuration: {e}")
1088: 
1089:     def setup_components(self):
1090: 
1091:         self.action_simulator = ActionSimulator(self.console, self)
1092:         self.key_handler = GlobalKeyHandler(self, self.action_simulator)
1093:         self.simulation_task = None
1094: 
1095:         # Now that ActionSimulator is initialized, we can load configuration values
1096:         self.load_configuration_values()
1097: 
1098:     async def choose_file(self, widget):
1099: 
1100:         try:
1101:             dialog = toga.OpenFileDialog(
1102:                 title="Select a Code File",
1103:                 file_types=["txt"]
1104:             )
1105:             file_path = await self.main_window.dialog(dialog)
1106: 
1107:             # Handle the file_path based on its type
1108:             if file_path:
1109:                 # Convert PosixPath to string if needed
1110:                 if hasattr(file_path, 'resolve'):  # It's a Path object
1111:                     self.selected_file = str(file_path.resolve())
1112:                 elif isinstance(file_path, list) and file_path:  # It's a list of paths
1113:                     self.selected_file = str(file_path[0])
1114:                 else:  # It's already a string
1115:                     self.selected_file = str(file_path)
1116: 
1117:                 filename = os.path.basename(self.selected_file)
1118:                 self.file_display.text = f"Selected: {filename}"
1119:                 logger.info(f"Selected file: {self.selected_file}")
1120:                 self.status_label.text = f"File selected: {filename}"
1121:             else:
1122:                 self.selected_file = None
1123:                 self.file_display.text = "Using default resources/code files"
1124:                 logger.info("No file selected; using default.")
1125:                 self.status_label.text = "Using default files"
1126:         except Exception as e:
1127:             self.console.value += f"Error selecting file: {str(e)}\n"
1128:             logger.error(f"Error in choose_file: {e}")
1129:             self.selected_file = None
1130:             self.file_display.text = "Using default resources/code files"
1131: 
1132:     async def start_simulation(self, widget):
1133: 
1134:         if not self.action_simulator.loop_flag:
1135:             try:
1136:                 self.console.value = "üöÄ Starting simulation...\n"
1137:                 self.update_button_states(running=True)
1138:                 self.action_simulator.loop_flag = True
1139:                 self.status_label.text = "Simulation running"
1140: 
1141:                 # Get the selected simulation mode
1142:                 selected_mode = self.mode_selector.value
1143:                 self.action_simulator.simulation_mode = selected_mode
1144:                 self.console.value += f"‚ñ∂Ô∏è Mode: {selected_mode}\n"
1145: 
1146:                 # Determine which file to use based on the selected mode and whether a file was chosen
1147:                 file_to_use = None
1148:                 if selected_mode in ["Typing Only", "Hybrid"]:
1149:                     if self.selected_file and os.path.exists(self.selected_file):
1150:                         file_to_use = self.selected_file
1151:                         filename = os.path.basename(file_to_use)
1152:                         self.console.value += f"üìÑ Using selected file: {filename}\n"
1153:                         logger.info(f"Using selected file: {file_to_use}")
1154:                     else:
1155:                         self.console.value += "üìÑ No valid file selected. Using default code samples\n"
1156:                         logger.info("No valid file selected, using default code samples")
1157:                 else:
1158:                     self.console.value += "üìÑ File selection not applicable for this mode\n"
1159:                     logger.info("File selection not applicable for this mode")
1160: 
1161:                 # Start the simulation task
1162:                 if not self.simulation_task:
1163:                     self.simulation_task = asyncio.create_task(self.run_continuous_simulation(file_to_use))
1164:                 logger.info("Simulation started successfully.")
1165:             except Exception as e:
1166:                 logger.error(f"Error starting simulation: {e}")
1167:                 await self.stop_simulation(widget)
1168: 
1169:     async def run_continuous_simulation(self, file_to_use: Optional[str]):
1170: 
1171:         try:
1172:             while self.action_simulator.loop_flag:
1173:                 # Determine which file to use
1174:                 if file_to_use and os.path.exists(file_to_use):
1175:                     next_file = file_to_use
1176:                     logger.debug(f"Using provided file: {next_file}")
1177:                 else:
1178:                     next_file = self.action_simulator.get_next_code_file()
1179:                     logger.debug(f"Using default file: {next_file}")
1180: 
1181:                 if not next_file:
1182:                     self.console.value += "‚ùå No code files found to simulate typing.\n"
1183:                     await asyncio.sleep(2)
1184:                     continue
1185: 
1186:                 # Calculate typing time if applicable
1187:                 if self.action_simulator.simulation_mode in ["Typing Only", "Hybrid"]:
1188:                     await self.action_simulator.calculate_typing_time(next_file)
1189: 
1190:                 # Execute the simulation based on the selected mode
1191:                 if self.action_simulator.simulation_mode == "Typing Only":
1192:                     self.console.value += "‚å®Ô∏è Simulating typing...\n"
1193:                     await self.action_simulator.simulate_typing(next_file)
1194:                 elif self.action_simulator.simulation_mode == "Tab Switching Only":
1195:                     self.console.value += "üîÑ Switching between applications...\n"
1196:                     self.action_simulator.switch_window()
1197:                     await asyncio.sleep(2)
1198:                 elif self.action_simulator.simulation_mode == "Hybrid":
1199:                     self.console.value += "‚å®Ô∏è Simulating typing...\n"
1200:                     await self.action_simulator.simulate_typing(next_file)
1201:                     self.console.value += "üîÑ Switching between applications...\n"
1202:                     self.action_simulator.switch_window()
1203:                     await asyncio.sleep(2)
1204:                 elif self.action_simulator.simulation_mode == "Mouse and Command+Tab":
1205:                     # Use the dedicated method for this simulation mode
1206:                     await self.action_simulator.simulate_mouse_and_command_tab(duration=15)  # Run for 15 seconds
1207: 
1208:                 filename = os.path.basename(next_file)
1209:                 self.console.value += f"\n‚úÖ Finished simulating file: {filename}\n"
1210:                 self.console.value += "üîÑ Cycle completed. Restarting...\n\n"
1211:                 self.status_label.text = "Cycle completed"
1212:                 await asyncio.sleep(2)
1213:         except asyncio.CancelledError:
1214:             self.console.value += "‚èπÔ∏è Simulation task cancelled.\n"
1215:             self.status_label.text = "Simulation cancelled"
1216:         except Exception as e:
1217:             self.console.value += f"‚ùå Error during simulation: {str(e)}\n"
1218:             self.status_label.text = "Error in simulation"
1219:             logger.error(f"Error in continuous simulation: {e}")
1220:             await self.stop_simulation(None)
1221: 
1222:     async def stop_simulation(self, widget):
1223: 
1224:         if self.action_simulator.loop_flag:
1225:             try:
1226:                 self.console.value += "‚èπÔ∏è Stopping simulation...\n"
1227:                 self.action_simulator.loop_flag = False
1228:                 self.update_button_states(running=False)
1229:                 self.status_label.text = "Simulation stopped"
1230:                 if self.simulation_task:
1231:                     self.simulation_task.cancel()
1232:                     self.simulation_task = None
1233:                 logger.info("Simulation stopped successfully.")
1234:             except Exception as e:
1235:                 logger.error(f"Error stopping simulation: {e}")
1236: 
1237:     def update_button_states(self, running: bool):
1238: 
1239:         self.start_button.enabled = not running
1240:         self.stop_button.enabled = running
1241: 
1242: 
1243: def main():
1244:     return CodeSimulator()

================
File: src/codesimulator/config.py
================
  1: import sys
  2: import json
  3: import os
  4: 
  5: from typing import Dict, List
  6: from .logging_config import logger
  7: 
  8: DEFAULT_APPS = {
  9:     'darwin': {
 10:         'applications': [
 11:             {
 12:                 'name': 'Google Chrome',
 13:                 'process_name': 'Google Chrome',
 14:                 'bundle_id': 'com.google.Chrome',
 15:             },
 16:             {
 17:                 'name': 'IntelliJ IDEA',
 18:                 'process_name': 'IntelliJ IDEA',
 19:                 'bundle_id': 'com.jetbrains.intellij',
 20:             },
 21:             {
 22:                 'name': 'Sublime Text',
 23:                 'process_name': 'Sublime Text',
 24:                 'bundle_id': 'com.sublimetext.4',
 25:             }
 26:         ]
 27:     },
 28:     'win32': {
 29:         'applications': [
 30:             {
 31:                 'name': 'Google Chrome',
 32:                 'process_name': 'chrome.exe',
 33:                 'window_class': 'Chrome_WidgetWin_1',
 34:             },
 35:             {
 36:                 'name': 'IntelliJ IDEA',
 37:                 'process_name': 'idea64.exe',
 38:                 'window_class': 'SunAwtFrame',
 39:             },
 40:             {
 41:                 'name': 'Sublime Text',
 42:                 'process_name': 'sublime_text.exe',
 43:                 'window_class': 'PX_WINDOW_CLASS',
 44:             }
 45:         ]
 46:     },
 47:     'linux': {
 48:         'applications': [
 49:             {
 50:                 'name': 'Google Chrome',
 51:                 'process_name': 'chrome',
 52:                 'window_class': 'Google-chrome',
 53:             },
 54:             {
 55:                 'name': 'IntelliJ IDEA',
 56:                 'process_name': 'idea.sh',
 57:                 'window_class': 'jetbrains-idea',
 58:             },
 59:             {
 60:                 'name': 'Sublime Text',
 61:                 'process_name': 'sublime_text',
 62:                 'window_class': 'sublime_text',
 63:             }
 64:         ]
 65:     }
 66: }
 67: 
 68: 
 69: class AppConfig:
 70:     def __init__(self, app=None):
 71:         self.app = app
 72:         self.config_path = self._get_config_path()
 73:         self.platform = sys.platform
 74:         self.apps = self._load_config()
 75: 
 76:     def _get_config_path(self) -> str:
 77: 
 78:         from .path_utils import get_resource_path
 79:         return get_resource_path(self.app, 'applications.json')
 80: 
 81:     def _load_config(self) -> Dict:
 82: 
 83:         try:
 84:             if os.path.exists(self.config_path):
 85:                 with open(self.config_path, 'r') as f:
 86:                     config = json.load(f)
 87:                     if self.platform in config:
 88:                         return config
 89: 
 90: 
 91:             return self._create_default_config()
 92:         except Exception as e:
 93:             logger.error(f"Error loading config3: {e}")
 94:             return self._create_default_config()
 95: 
 96:     def _create_default_config(self) -> Dict:
 97: 
 98:         config = DEFAULT_APPS
 99:         try:
100:             with open(self.config_path, 'w') as f:
101:                 json.dump(config, f, indent=4)
102:         except Exception as e:
103:             logger.error(f"Error saving default config: {e}")
104:         return config
105: 
106:     def get_applications(self) -> List[Dict]:
107: 
108:         return self.apps.get(self.platform, {}).get('applications', [])
109: 
110:     def add_application(self, app_info: Dict) -> bool:
111: 
112:         try:
113:             if self.platform not in self.apps:
114:                 self.apps[self.platform] = {'applications': []}
115: 
116:             self.apps[self.platform]['applications'].append(app_info)
117: 
118:             with open(self.config_path, 'w') as f:
119:                 json.dump(self.apps, f, indent=4)
120:             return True
121:         except Exception as e:
122:             logger.error(f"Error adding application: {e}")
123:             return False
124: 
125:     def remove_application(self, app_name: str) -> bool:
126: 
127:         try:
128:             if self.platform in self.apps:
129:                 apps = self.apps[self.platform]['applications']
130:                 self.apps[self.platform]['applications'] = [
131:                     app for app in apps if app['name'] != app_name
132:                 ]
133: 
134:                 with open(self.config_path, 'w') as f:
135:                     json.dump(self.apps, f, indent=4)
136:                 return True
137:         except Exception as e:
138:             logger.error(f"Error removing application: {e}")
139:         return False

================
File: src/codesimulator/key_handler.py
================
  1: import asyncio
  2: from platform import system
  3: import sys
  4: from .logging_config import logger
  5: 
  6: 
  7: class GlobalKeyHandler:
  8: 
  9:     def __init__(self, app, action_simulator):
 10:         self.app = app
 11:         self.action_simulator = action_simulator
 12:         self.platform = sys.platform
 13:         self.keyboard_listener = None
 14:         self._setup_platform_handler()
 15: 
 16:     def _setup_platform_handler(self):
 17:         try:
 18:             if self.platform == 'darwin':
 19:                 self._setup_macos_handler()
 20:             elif self.platform == 'win32':
 21:                 self._setup_windows_handler()
 22:             else:
 23:                 self._setup_linux_handler()
 24:         except Exception as e:
 25:             logger.error(f"Error setting up key handler: {e}")
 26: 
 27:     def _setup_macos_handler(self):
 28:         try:
 29:             import Quartz
 30:             from AppKit import NSEvent, NSKeyDownMask, NSEventModifierFlagCommand
 31: 
 32:             def handle_ns_event(event):
 33:                 if event.type() == NSKeyDownMask:
 34: 
 35:                     command_key = (event.modifierFlags() & NSEventModifierFlagCommand) != 0
 36:                     key = event.charactersIgnoringModifiers()
 37: 
 38: 
 39:                     if command_key and key.lower() == 's':
 40:                         logger.info("Global hotkey detected: Command+S (start simulation)")
 41:                         self.toggle_simulation()
 42: 
 43:                     elif command_key and key.lower() == 'x':
 44:                         logger.info("Global hotkey detected: Command+X (stop simulation)")
 45:                         self.app.stop_simulation(None)
 46: 
 47: 
 48:             NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(
 49:                 NSKeyDownMask,
 50:                 handle_ns_event
 51:             )
 52:             logger.info("MacOS global key handler initialized successfully")
 53:         except ImportError as e:
 54:             logger.error(f"Failed to import MacOS modules: {e}")
 55:         except Exception as e:
 56:             logger.error(f"Failed to initialize MacOS key handler: {e}")
 57: 
 58:     def _setup_windows_handler(self):
 59:         try:
 60:             from pynput import keyboard
 61: 
 62:             def on_press(key):
 63:                 try:
 64: 
 65:                     if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
 66:                         self.ctrl_pressed = True
 67:                     elif hasattr(key, 'char') and self.ctrl_pressed and key.char.lower() == 's':
 68:                         logger.info("Global hotkey detected: Ctrl+S (start simulation)")
 69:                         self.toggle_simulation()
 70: 
 71:                     elif hasattr(key, 'char') and self.ctrl_pressed and key.char.lower() == 'x':
 72:                         logger.info("Global hotkey detected: Ctrl+X (stop simulation)")
 73:                         self.app.stop_simulation(None)
 74:                 except AttributeError:
 75: 
 76:                     pass
 77:                 except Exception as e:
 78:                     logger.error(f"Error in keyboard handler: {e}")
 79: 
 80:             def on_release(key):
 81:                 if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
 82:                     self.ctrl_pressed = False
 83: 
 84: 
 85:             self.ctrl_pressed = False
 86: 
 87: 
 88:             self.keyboard_listener = keyboard.Listener(
 89:                 on_press=on_press,
 90:                 on_release=on_release
 91:             )
 92:             self.keyboard_listener.start()
 93:             logger.info("Windows global key handler initialized successfully")
 94:         except ImportError:
 95:             logger.error("pynput module not found. Please install with: pip install pynput")
 96:         except Exception as e:
 97:             logger.error(f"Failed to initialize Windows key handler: {e}")
 98: 
 99:     def _setup_linux_handler(self):
100:         try:
101:             from pynput import keyboard
102: 
103:             def on_press(key):
104:                 try:
105: 
106:                     if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
107:                         self.ctrl_pressed = True
108:                     elif hasattr(key, 'char') and self.ctrl_pressed and key.char and key.char.lower() == 's':
109:                         logger.info("Global hotkey detected: Ctrl+S (start simulation)")
110:                         self.toggle_simulation()
111: 
112:                     elif hasattr(key, 'char') and self.ctrl_pressed and key.char and key.char.lower() == 'x':
113:                         logger.info("Global hotkey detected: Ctrl+X (stop simulation)")
114:                         self.app.stop_simulation(None)
115:                 except AttributeError:
116: 
117:                     pass
118:                 except Exception as e:
119:                     logger.error(f"Error in keyboard handler: {e}")
120: 
121:             def on_release(key):
122:                 if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
123:                     self.ctrl_pressed = False
124: 
125: 
126:             self.ctrl_pressed = False
127: 
128: 
129:             self.keyboard_listener = keyboard.Listener(
130:                 on_press=on_press,
131:                 on_release=on_release
132:             )
133:             self.keyboard_listener.start()
134:             logger.info("Linux global key handler initialized successfully")
135:         except ImportError:
136:             logger.error("pynput module not found. Please install with: pip install pynput")
137:         except Exception as e:
138:             logger.error(f"Failed to initialize Linux key handler: {e}")
139: 
140:     async def run(self):
141:         try:
142:             logger.info("Global key handler started")
143:             while True:
144:                 await asyncio.sleep(0.1)
145:         except asyncio.CancelledError:
146:             logger.info("Key handler task cancelled")
147:         except Exception as e:
148:             logger.error(f"Error in key handler: {e}")
149: 
150:     def toggle_simulation(self):
151:         try:
152:             if self.action_simulator.loop_flag:
153:                 self.app.stop_simulation(None)
154:             else:
155:                 self.app.start_simulation(None)
156:         except Exception as e:
157:             logger.error(f"Error toggling simulation: {e}")
158: 
159:     def cleanup(self):
160:         try:
161:             if self.keyboard_listener:
162:                 self.keyboard_listener.stop()
163:                 logger.info("Keyboard listener stopped")
164:             logger.info("Key handler cleanup completed")
165:         except Exception as e:
166:             logger.error(f"Error during key handler cleanup: {e}")

================
File: src/codesimulator/language_formatter.py
================
  1: import re
  2: from .logging_config import logger
  3: 
  4: 
  5: class LanguageFormatter:
  6: 
  7: 
  8:     def __init__(self, indent_size=4):
  9:         self.indent_size = indent_size
 10:         self.indent_level = 0
 11:         self.indent_style = " " * indent_size
 12: 
 13:     def format_line(self, line: str) -> str:
 14: 
 15:         line = line.strip()
 16: 
 17: 
 18:         if line.endswith("{") or line.endswith("("):
 19:             indented_line = self.indent_style * self.indent_level + line
 20:             self.indent_level += 1
 21:         elif line.startswith("}") or line.startswith(")"):
 22:             self.indent_level = max(0, self.indent_level - 1)
 23:             indented_line = self.indent_style * self.indent_level + line
 24:         else:
 25:             indented_line = self.indent_style * self.indent_level + line
 26: 
 27:         return indented_line
 28: 
 29: 
 30: class JavaFormatter(LanguageFormatter):
 31: 
 32: 
 33:     def format_line(self, line: str) -> str:
 34: 
 35:         line = super().format_line(line)
 36: 
 37: 
 38: 
 39:         line = re.sub(r"(?<=\w),(?=\w)", ", ", line)
 40: 
 41: 
 42:         if line.endswith("{"):
 43:             indented_line = self.indent_style * self.indent_level + line
 44:             self.indent_level += 1
 45:         elif line.startswith("}"):
 46:             self.indent_level = max(0, self.indent_level - 1)
 47:             indented_line = self.indent_style * self.indent_level + line
 48:         elif (
 49:                 line.startswith("if")
 50:                 or line.startswith("else")
 51:                 or line.startswith("for")
 52:                 or line.startswith("while")
 53:         ):
 54:             indented_line = self.indent_style * self.indent_level + line
 55:             self.indent_level += 1
 56:         else:
 57:             indented_line = self.indent_style * self.indent_level + line
 58: 
 59:         return indented_line
 60: 
 61: 
 62: class PythonFormatter(LanguageFormatter):
 63: 
 64: 
 65:     def format_line(self, line: str) -> str:
 66: 
 67:         line = super().format_line(line)
 68: 
 69: 
 70: 
 71:         if re.match(
 72:                 r"^(if|elif|else|for|while|try|except|finally|def|class)\b.*[^:]$", line
 73:         ):
 74:             line = line + ":"
 75: 
 76:         return line
 77: 
 78: 
 79: class PHPFormatter(LanguageFormatter):
 80: 
 81: 
 82:     def format_line(self, line: str) -> str:
 83: 
 84:         line = super().format_line(line)
 85: 
 86: 
 87: 
 88:         line = re.sub(r"(\s*)(=|!=|==|<=|>=|<|>|\+|-|\*|\/|%|&&|\|\|)(\s*)", r" \1 ", line)
 89: 
 90: 
 91:         line = re.sub(r"(,)(?=\S)", r"$1 ", line)
 92: 
 93: 
 94:         line = re.sub(r"\s+\)", ")", line)
 95: 
 96: 
 97:         if line.endswith("{"):
 98:             indented_line = self.indent_style * self.indent_level + line
 99:             self.indent_level += 1
100:         elif line.startswith("}"):
101:             self.indent_level = max(0, self.indent_level - 1)
102:             indented_line = self.indent_style * self.indent_level + line
103:         elif (
104:                 line.startswith("if")
105:                 or line.startswith("else")
106:                 or line.startswith("elseif")
107:                 or line.startswith("for")
108:                 or line.startswith("foreach")
109:                 or line.startswith("while")
110:                 or line.startswith("function")
111:         ):
112:             indented_line = self.indent_style * self.indent_level + line
113:             self.indent_level += 1
114:         else:
115:             indented_line = self.indent_style * self.indent_level + line
116: 
117:         return indented_line
118: 
119: 
120: 
121: 
122: 
123: class FormatterFactory:
124: 
125: 
126:     @staticmethod
127:     def create_formatter(language: str, indent_size: int = 4) -> LanguageFormatter:
128: 
129:         if language == "java":
130:             return JavaFormatter(indent_size)
131:         elif language == "python":
132:             return PythonFormatter(indent_size)
133:         elif language == "php":
134:             return PHPFormatter(indent_size)
135: 
136:         else:
137:             logger.warning(
138:                 f"No specific formatter found for {language}. Using default formatter."
139:             )
140:             return LanguageFormatter(indent_size)

================
File: src/codesimulator/logging_config.py
================
 1: import logging
 2: import logging.handlers
 3: import os
 4: import sys
 5: import tempfile
 6: import platform
 7: 
 8: 
 9: logger = logging.getLogger('codesimulator')
10: logger.setLevel(logging.DEBUG)
11: 
12: 
13: console_handler = logging.StreamHandler()
14: console_handler.setLevel(logging.INFO)
15: formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
16: console_handler.setFormatter(formatter)
17: logger.addHandler(console_handler)
18: 
19: 
20: _file_logging_initialized = False
21: 
22: 
23: def get_log_path():
24: 
25:     try:
26: 
27:         if platform.system() == "Darwin":
28:             # This directory should always be writable for the current user on macOS
29:             log_dir = os.path.join(os.path.expanduser('~'), 'Library', 'Logs', 'CodeSimulator')
30:         else:
31:             # For other platforms
32:             log_dir = os.path.join(tempfile.gettempdir(), 'CodeSimulator', 'logs')
33: 
34:         # Ensure directory exists
35:         os.makedirs(log_dir, exist_ok=True)
36: 
37:         # Return full path
38:         return os.path.join(log_dir, 'codesimulator.log')
39:     except Exception:
40:         # Ultimate fallback - use temp directory
41:         return os.path.join(tempfile.gettempdir(), 'codesimulator.log')
42: 
43: 
44: def setup_file_logging():
45: 
46:     global _file_logging_initialized
47: 
48: 
49:     if _file_logging_initialized:
50:         return
51: 
52:     try:
53: 
54:         log_file_path = get_log_path()
55: 
56: 
57:         file_handler = logging.handlers.RotatingFileHandler(
58:             log_file_path, maxBytes=5 * 1024 * 1024, backupCount=2
59:         )
60:         file_handler.setLevel(logging.DEBUG)
61:         file_handler.setFormatter(formatter)
62: 
63: 
64:         logger.addHandler(file_handler)
65: 
66: 
67:         _file_logging_initialized = True
68: 
69: 
70:         logger.info(f"File logging initialized at: {log_file_path}")
71: 
72:     except Exception as e:
73: 
74:         logger.error(f"Failed to set up file logging: {e}")
75: 
76: 
77: 
78: setup_file_logging()

================
File: src/codesimulator/mouse.py
================
 1: import asyncio
 2: import random
 3: import pyautogui
 4: from typing import Optional, Tuple
 5: from .logging_config import logger
 6: 
 7: 
 8: class MouseController:
 9: 
10: 
11:     def __init__(self):
12: 
13:         self.is_active = False
14:         self.screen_width, self.screen_height = pyautogui.size()
15:         self.movement_task: Optional[asyncio.Task] = None
16: 
17:     async def start_random_movement(self,
18:                                     min_interval: float = 5.0,
19:                                     max_interval: float = 15.0,
20:                                     excluded_zone: Optional[Tuple[int, int, int, int]] = None):
21: 
22:         self.is_active = True
23: 
24:         while self.is_active:
25:             try:
26: 
27:                 x = random.randint(0, self.screen_width)
28:                 y = random.randint(0, self.screen_height)
29: 
30: 
31:                 if excluded_zone:
32:                     x1, y1, x2, y2 = excluded_zone
33:                     if x1 <= x <= x2 and y1 <= y <= y2:
34:                         continue
35: 
36: 
37:                 current_x, current_y = pyautogui.position()
38:                 distance = ((x - current_x) ** 2 + (y - current_y) ** 2) ** 0.5
39:                 duration = min(2.0, distance / 1000)
40: 
41: 
42:                 pyautogui.moveTo(x, y, duration=duration)
43:                 logger.debug(f"Moved mouse to ({x}, {y})")
44: 
45: 
46:                 wait_time = random.uniform(min_interval, max_interval)
47:                 await asyncio.sleep(wait_time)
48: 
49:             except Exception as e:
50:                 logger.error(f"Error in mouse movement: {e}")
51:                 await asyncio.sleep(1)
52: 
53:     def start(self,
54:               min_interval: float = 5.0,
55:               max_interval: float = 15.0,
56:               excluded_zone: Optional[Tuple[int, int, int, int]] = None):
57: 
58:         if self.movement_task and not self.movement_task.done():
59:             return
60: 
61:         self.movement_task = asyncio.create_task(
62:             self.start_random_movement(min_interval, max_interval, excluded_zone)
63:         )
64: 
65:     def stop(self):
66: 
67:         self.is_active = False
68:         if self.movement_task:
69:             self.movement_task.cancel()
70:             self.movement_task = None

================
File: src/codesimulator/path_utils.py
================
  1: import os
  2: import sys
  3: import tempfile
  4: import platform
  5: from .logging_config import logger
  6: 
  7: 
  8: def is_packaged():
  9: 
 10:     return getattr(sys, 'frozen', False)
 11: 
 12: 
 13: def get_resource_path(app=None, *paths):
 14: 
 15:     try:
 16: 
 17:         if app and hasattr(app, 'paths') and hasattr(app.paths, 'resources'):
 18:             base_path = app.paths.resources
 19:             logger.debug(f"Using Toga resource path: {base_path}")
 20:         else:
 21:             # Fallback based on environment
 22:             if is_packaged():
 23:                 # Packaged app - path depends on platform
 24:                 if platform.system() == 'Darwin':  # macOS
 25:                     base_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(sys.executable))),
 26:                                              'Resources')
 27:                 elif platform.system() == 'Windows':
 28:                     base_path = os.path.join(os.path.dirname(sys.executable), 'app', 'resources')
 29:                 else:  # Linux and others
 30:                     base_path = os.path.join(os.path.dirname(sys.executable), 'resources')
 31:                 logger.debug(f"Using packaged resource path: {base_path}")
 32:             else:
 33:                 # Development environment
 34:                 base_path = os.path.join(os.path.dirname(__file__), 'resources')
 35:                 logger.debug(f"Using development resource path: {base_path}")
 36: 
 37:         full_path = os.path.join(base_path, *paths)
 38:         logger.debug(f"Full resource path: {full_path}")
 39:         return full_path
 40:     except Exception as e:
 41:         logger.error(f"Error getting resource path: {e}")
 42:         # Last resort fallback
 43:         return os.path.join(os.path.dirname(__file__), 'resources', *paths)
 44: 
 45: 
 46: def get_log_path():
 47: 
 48:     if is_packaged():
 49:         # Use system temp directory for packaged app
 50:         log_dir = tempfile.gettempdir()
 51:     else:
 52:         # Use resources directory in development
 53:         log_dir = os.path.join(os.path.dirname(__file__), 'resources')
 54: 
 55:     if not os.path.exists(log_dir):
 56:         try:
 57:             os.makedirs(log_dir)
 58:         except Exception:
 59:             pass
 60: 
 61:     return os.path.join(log_dir, 'codesimulator.log')
 62: 
 63: 
 64: def log_environment_info():
 65: 
 66:     info = {
 67:         "Platform": platform.system(),
 68:         "Python Version": sys.version,
 69:         "Packaged App": is_packaged(),
 70:         "Executable Path": sys.executable,
 71:         "Current Directory": os.getcwd(),
 72:         "Module Path": os.path.dirname(__file__),
 73:         "Resource Path Example": get_resource_path(None, 'config.json')
 74:     }
 75: 
 76:     for key, value in info.items():
 77:         logger.info(f"{key}: {value}")
 78: 
 79: 
 80: def get_log_path():
 81: 
 82:     try:
 83:         if is_packaged():
 84:             # Use a more accessible location for packaged app
 85:             if platform.system() == "Windows":
 86:                 log_dir = os.path.join(os.environ.get('APPDATA', os.path.expanduser("~")), "CodeSimulator", "logs")
 87:             elif platform.system() == "Darwin":  # macOS
 88:                 log_dir = os.path.join(os.path.expanduser("~"), "Library", "Logs", "CodeSimulator")
 89:             else:  # Linux and others
 90:                 log_dir = os.path.join(os.path.expanduser("~"), ".codesimulator", "logs")
 91:         else:
 92:             # Use resources directory in development
 93:             log_dir = os.path.join(os.path.dirname(__file__), 'resources')
 94: 
 95:         # Create directory if it doesn't exist
 96:         if not os.path.exists(log_dir):
 97:             os.makedirs(log_dir)
 98: 
 99:         return os.path.join(log_dir, 'codesimulator.log')
100:     except Exception as e:
101: 
102:         import tempfile
103:         return os.path.join(tempfile.gettempdir(), 'codesimulator.log')

================
File: CHANGELOG
================
1: # Code Simulator Release Notes
2: 
3: ## 0.0.1 (12 Jan 2025)
4: 
5: * Initial release

================
File: LICENSE
================
 1: Copyright (c) 2025, rylxes
 2: All rights reserved.
 3: 
 4: Redistribution and use in source and binary forms, with or without modification,
 5: are permitted provided that the following conditions are met:
 6: 
 7: * Redistributions of source code must retain the above copyright notice, this
 8:   list of conditions and the following disclaimer.
 9: 
10: * Redistributions in binary form must reproduce the above copyright notice, this
11:   list of conditions and the following disclaimer in the documentation and/or
12:   other materials provided with the distribution.
13: 
14: * Neither the name of the copyright holder nor the names of its
15:   contributors may be used to endorse or promote products derived from this
16:   software without specific prior written permission.
17: 
18: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
19: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
20: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
21: IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
22: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
23: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
24: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
25: OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
26: OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
27: OF THE POSSIBILITY OF SUCH DAMAGE.

================
File: pyproject.toml
================
  1: # This project was generated with 0.3.20 using template: https://github.com/beeware/briefcase-template@v0.3.20
  2: [tool.briefcase]
  3: project_name = "Code Simulator"
  4: bundle = "com.rylxes.code-simulator"
  5: version = "0.0.1"
  6: url = "https://code-simulator.rylxes.com/codesimulator"
  7: license.file = "LICENSE"
  8: author = "rylxes"
  9: author_email = "rylxes@gmail.com"
 10: 
 11: [tool.briefcase.app.codesimulator]
 12: formal_name = "Code Simulator"
 13: description = "My first application"
 14: long_description = """More details about the app should go here.
 15: """
 16: sources = [
 17:     "src/codesimulator",
 18: ]
 19: test_sources = [
 20:     "tests",
 21: ]
 22: 
 23: requires = [
 24:     "pyautogui>=0.9.53",
 25:     "PyQt5>=5.15",
 26:     "pynput>=1.7.6"
 27: ]
 28: test_requires = [
 29:     "pytest",
 30: ]
 31: 
 32: resources = [
 33:     "src/codesimulator/resources",
 34: ]
 35: 
 36: [tool.briefcase.app.codesimulator.macOS]
 37: universal_build = true
 38: requires = [
 39:     "toga-cocoa~=0.4.7",
 40:     "std-nslog~=1.0.3",
 41:     "pyautogui>=0.9.53",
 42:     "PyQt5>=5.15",
 43:     "pynput>=1.7.6"
 44: ]
 45: 
 46: entitlements = [
 47:     "com.apple.security.automation.apple-events",
 48:     "com.apple.security.device.camera",  # if needed
 49:     "com.apple.security.device.audio-input",  # if needed
 50: ]
 51: 
 52: 
 53: [tool.briefcase.app.codesimulator.macOS.info]
 54: NSAppleEventsUsageDescription = "Code Simulator needs to control other applications to perform simulations."
 55: NSAccessibilityUsageDescription = "Code Simulator needs accessibility access to simulate keyboard and mouse inputs."
 56: 
 57: [tool.briefcase.app.codesimulator.linux]
 58: requires = [
 59:     "toga-cocoa~=0.4.7",
 60:     "std-nslog~=1.0.3",
 61:     "pyautogui>=0.9.53",
 62:     "PyQt5>=5.15",
 63:     "pynput>=1.7.6"
 64: ]
 65: 
 66: [tool.briefcase.app.codesimulator.linux.system.debian]
 67: system_requires = [
 68:     # Needed to compile pycairo wheel
 69:     "libcairo2-dev",
 70:     # Needed to compile PyGObject wheel
 71:     "libgirepository1.0-dev",
 72: ]
 73: 
 74: system_runtime_requires = [
 75:     # Needed to provide GTK and its GI bindings
 76:     "gir1.2-gtk-3.0",
 77:     "libgirepository-1.0-1",
 78:     # Dependencies that GTK looks for at runtime
 79:     "libcanberra-gtk3-module",
 80:     # Needed to provide WebKit2 at runtime
 81:     # Note: Debian 11 and Ubuntu 20.04 require gir1.2-webkit2-4.0 instead
 82:     # "gir1.2-webkit2-4.1",
 83: ]
 84: 
 85: [tool.briefcase.app.codesimulator.linux.system.rhel]
 86: system_requires = [
 87:     # Needed to compile pycairo wheel
 88:     "cairo-gobject-devel",
 89:     # Needed to compile PyGObject wheel
 90:     "gobject-introspection-devel",
 91: ]
 92: 
 93: system_runtime_requires = [
 94:     # Needed to support Python bindings to GTK
 95:     "gobject-introspection",
 96:     # Needed to provide GTK
 97:     "gtk3",
 98:     # Dependencies that GTK looks for at runtime
 99:     "libcanberra-gtk3",
100:     # Needed to provide WebKit2 at runtime
101:     # "webkit2gtk3",
102: ]
103: 
104: [tool.briefcase.app.codesimulator.linux.system.suse]
105: system_requires = [
106:     # Needed to compile pycairo wheel
107:     "cairo-devel",
108:     # Needed to compile PyGObject wheel
109:     "gobject-introspection-devel",
110: ]
111: 
112: system_runtime_requires = [
113:     # Needed to provide GTK
114:     "gtk3",
115:     # Needed to support Python bindings to GTK
116:     "gobject-introspection", "typelib(Gtk) = 3.0",
117:     # Dependencies that GTK looks for at runtime
118:     "libcanberra-gtk3-module",
119:     # Needed to provide WebKit2 at runtime
120:     # "libwebkit2gtk3", "typelib(WebKit2)",
121: ]
122: 
123: [tool.briefcase.app.codesimulator.linux.system.arch]
124: system_requires = [
125:     # Needed to compile pycairo wheel
126:     "cairo",
127:     # Needed to compile PyGObject wheel
128:     "gobject-introspection",
129:     # Runtime dependencies that need to exist so that the
130:     # Arch package passes final validation.
131:     # Needed to provide GTK
132:     "gtk3",
133:     # Dependencies that GTK looks for at runtime
134:     "libcanberra",
135:     # Needed to provide WebKit2
136:     # "webkit2gtk",
137: ]
138: 
139: system_runtime_requires = [
140:     # Needed to provide GTK
141:     "gtk3",
142:     # Needed to provide PyGObject bindings
143:     "gobject-introspection-runtime",
144:     # Dependencies that GTK looks for at runtime
145:     "libcanberra",
146:     # Needed to provide WebKit2 at runtime
147:     # "webkit2gtk",
148: ]
149: 
150: [tool.briefcase.app.codesimulator.linux.appimage]
151: manylinux = "manylinux_2_28"
152: 
153: system_requires = [
154:     # Needed to compile pycairo wheel
155:     "cairo-gobject-devel",
156:     # Needed to compile PyGObject wheel
157:     "gobject-introspection-devel",
158:     # Needed to provide GTK
159:     "gtk3-devel",
160:     # Dependencies that GTK looks for at runtime, that need to be
161:     # in the build environment to be picked up by linuxdeploy
162:     "libcanberra-gtk3",
163:     "PackageKit-gtk3-module",
164:     "gvfs-client",
165: ]
166: 
167: linuxdeploy_plugins = [
168:     "DEPLOY_GTK_VERSION=3 gtk",
169: ]
170: 
171: [tool.briefcase.app.codesimulator.linux.flatpak]
172: flatpak_runtime = "org.gnome.Platform"
173: flatpak_runtime_version = "47"
174: flatpak_sdk = "org.gnome.Sdk"
175: 
176: [tool.briefcase.app.codesimulator.windows]
177: requires = [
178:     "toga-winforms~=0.4.7",
179:     "pyautogui>=0.9.53",
180:     "PyQt5>=5.15",
181:     "pynput>=1.7.6"
182: ]
183: 
184: # Mobile deployments
185: [tool.briefcase.app.codesimulator.iOS]
186: requires = [
187:     "toga-iOS~=0.4.7",
188:     "std-nslog~=1.0.3",
189: ]
190: 
191: [tool.briefcase.app.codesimulator.android]
192: requires = [
193:     "toga-android~=0.4.7",
194: ]
195: 
196: base_theme = "Theme.MaterialComponents.Light.DarkActionBar"
197: 
198: build_gradle_dependencies = [
199:     "com.google.android.material:material:1.12.0",
200:     # Needed for DetailedList
201:     # "androidx.swiperefreshlayout:swiperefreshlayout:1.1.0",
202:     # Needed for MapView
203:     # "org.osmdroid:osmdroid-android:6.1.20",
204: ]
205: 
206: # Web deployments
207: [tool.briefcase.app.codesimulator.web]
208: requires = [
209:     "toga-web~=0.4.7",
210:     "pyautogui>=0.9.53",
211:     "PyQt5>=5.15"
212: ]
213: style_framework = "Shoelace v2.3"

================
File: README.rst
================
1: briefcase package
2:  briefcase dev -r



================================================================
End of Codebase
================================================================
